## C++ クラスと C 構造体の違い

C++ クラスは C 構造体の概念を内包しています。
[POD](https://en.cppreference.com/w/cpp/named_req/PODType) (Plain Old Data) class は C 構造体として C 関数に渡せる、`memcpy` でコピーできるなどの特徴を持ちます。
C++11 では、POD の定義が [standard-layout](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType) class と [trivial](https://en.cppreference.com/w/cpp/named_req/TrivialType) class というふたつの概念で表現されるようになり、C++20 では POD よりも後者の概念が主体的に扱われるようになります。
Standard-layout class は C 構造体として C 関数に渡せることを、trivial class は `memcpy` でコピーできることを念頭に定義がされています。
C 言語で使っていた `struct` の機能以上のものを使っておらず、メンバ変数もそうであるクラスは、間違いなく standard-layout かつ trivial なので安心してください。
逆にいえば、C 構造体として C 関数に渡してはいけなかったり、`memcpy` してはいけないクラスが存在するということです。
例えば、仮想関数をメンバに持つクラスは standard-layout でも trivial でもありません。
仮想テーブルのような隠れたデータを持つことがあり、`memcpy` するとデータが破壊されることがあります。


### コンストラクタとデストラクタ

C++ クラスはコンストラクタとデストラクタを持ちます。
コンストラクタはオブジェクトの初期化時に実行されるコードで、デストラクタは開放時に実行されるコードです。
これらは返り値を持ちません。
コンストラクタはシグネチャ(簡単に言うと仮引数の数や型)が異なれば複数定義できますが、デストラクタは引数を持たないものひとつだけです。
特殊なコンストラクタとして、デフォルトコンストラクタ (`T()`)、コピーコンストラクタ(`T(const T&)`)、ムーヴコンストラクタ(`T(T&&)`) があります。


### メンバ関数

クラスにはメンバ関数を定義できます。
メンバ関数は、そのクラス特有の処理を行うときに便利です。
また、メンバ関数の名前が、同じクラス内のメンバ関数以外からは見えないというメリットや、C 構造体の要素に相当するメンバ変数、とりわけ非公開のメンバ変数に直接アクセスできるメリットがあります。
これはメンバ関数やメンバ変数のスコープがクラススコープであるからです。
メンバ関数の引数にはクラス外部のもののみ渡せばよいので、シグネチャがスッキリし、分かりやすくなります。

ある処理をグローバル関数とメンバ関数のどちらにすべきか悩んだ場合は、それらのメリットデリットを天秤にかけて決めてください。
非公開メンバ変数にアクセスする必要がないのにメンバ関数にする必要はあまりないと思いますが、迷った時は使いやすい方、メンテナンスしやすい方を選ぶのが良いでしょう。


### オーバーロード

[オーバーロード](https://en.cppreference.com/w/cpp/language/overload_resolution)とは、同じ名前の関数でも仮引数の数や型が異なれば別の関数として扱うことのできる仕組みです。
あるクラスでコンストラクタを複数定義したときもオーバーロードしています。
何が区別され、何が区別されないかについて、厳密な条件はかなり複雑です。
簡単に確認する方法は、実際に複数の同じ名前の関数やテンプレートを定義してみて、コンパイルエラーになるかどうかを見ることです。
また、ある引数リストを与えたときに、どのシグネチャが選ばれるのかも、試してみるのが一番早いと思います。
避けられない場合を除き、オーバーロード関数をたくさん定義するのは良いこととはいえません。
どのシグネチャが選ばれるか分かりづらいと可読性やメンテナンス性が落ちるのはいうまでもありません。
複雑なものは分かりにくいのです。
同じ名前にする意味があるのかどうかを自問自答してください。
別名でも問題ないのなら別名にしてください。
迷ったら別名にすべきです。

オーバーロードを使う典型的な例をいくつか挙げておきます:

1. コンストラクタ
2. メンバ関数の const 版と non-const 版
3. const lvalue 参照を受けとるコピー版と、rvalue 参照を受けとるムーヴ版
4. 異なる型を扱うが同じ操作を意味する関数、演算子

最後の例は、テンプレート関数を定義することで、オーバーロードされた複数の関数をまとめて自動生成することも多いと思います。


### 継承の使いどころ

継承は、本当にすべきかどうかをよく考えてからにしてください。
`is-a` と `has-a` の違いについて調べてください。
昨今の C++ で継承を利用すべきケースは初心者の方が思っているよりもかなり限られます。
不用意な継承の使用は、メンテナンス性の悪いコードへの第一歩となります。

仕方なく継承を使うケースとして、多態 (polymorphism) が挙げられます。
多態とは、ここでは、基底クラス型のポインタに、複数の派生クラス型のオブジェクトポインタを格納し、同じメンバ関数呼び出しでもオブジェクトの実際の型によって異なる挙動をさせる使い方を指します。
多態させるメンバ関数と、デストラクタは、 virtual メンバ関数にすることを忘れないでください。
C 言語だと `union` を使って行うような処理ですが、その場合は自分で型を判定できる要素を用意し、それを用いて条件分岐して挙動の変化を実現します。
virtual メンバ関数を定義してしまうと、オブジェクトは vtable という構造を持ち、関数呼出時に型によって処理を分岐するようになるため、オーバーヘッドが発生しますので注意が必要です。
逆に、virtual キーワードを指定しない場合、あるコードにおいて用いられる型は静的に(コンパイル時に)決まってしまうため、同じ名前のメンバ関数だけれど、オブジェクトの実際の型によって中身が異なるものを実行するという目的は達成できないでしょう。
以下の例に挙動の違いを示します。


```c++
#include <cstdio>
#include <memory>

struct A
{
    virtual void f1() { :: puts("A::f1"); }
    void f2() { ::puts("A::f2"); }
    virtual ~A() {}
};

struct B : A
{
    void f1() { ::puts("B::f1"); }
    void f2() { ::puts("B::f2"); }
    void f3() { ::puts("B::f3"); }
    ~B() {}
};

int main()
{
    A* p = new B;
    p->f1();  // B::f1 が表示される
    p->f2();  // A::f2 が表示される
    //p->f3();
    dynamic_cast<B*>(p)->f3();  // B::f3 が表示される
    ((B*)p)->f3();  // B::f3 が表示される
}
```
`A` のポインタであったとしても、`f1()` は virtual メンバ関数なので、多態に相応しい挙動をし、`B::f1()` が呼ばれます。
しかし、virtual ではない `f2()` は、`A*` の型だけ見てコンパイル時に呼ぶ関数を決定しますので、`A::f2()` が呼ばれます。
`f3()` に至っては `A` で定義されてないのでキャストなしでは呼ぶことすらできません。
それが `B` のオブジェクトであることを確信できる場合のみ `dynamic_cast` を使えますが、それはすなわち、`p` が指しているオブジェクトの型が `B` であるかどうかを判別する明示的な条件分岐を必要とするわけです。


また、継承を使うときに気をつけなければいけないこととして、一般にデストラクタの virtual 化が必要になります。
以下は悪い例です:

```c++
// 悪い例
struct A
{
  ~A() {}  // non-virtual destructor
};

struct B : A
{
   int *p;
   B() : p(new int(0)) {}
   ~B() { delete p; }
};

int main()
{
    A *a = new B();
    delete a;  // ~A() が呼ばれ、~B() は呼ばれないので、メモリリーク
}
```

この例では、`~A()` が virtual ではないので、`A*` 型の変数 `a` から `B` 型のオブジェクトを指しているとき、`delete a;` は `~A()` のデストラクタのみを呼んでしまい、メモリリークします。
`~A()` に virtual を指定しておけば、ポインタの型 (`A`) ではなく、実体の型 (`B`) のデストラクタを呼んでくれます。
`~B()` だけに virtual を指定しても `~A()` は自動的には virtual にならないため、やはりメモリリークしてしまうのが少しややこしいです。
`virtual` は子孫には伝搬しますが、先祖には伝搬しませんのでご注意ください。

Mix-in は、virtual メンバ関数を使わずに、派生型でメンバ変数を新たに定義せず、メンバ関数だけを増やす手法です。
派生型のデストラクタでは何もする必要がなく、基本型のデストラクタだけ呼ばれれば良いため、virtual デストラクタがなくても問題ありません。
Mix-in は vtable を必要とするクラスが持つデメリットの影響を受けないので気軽に使えますが、使いどころは限られます。

C++17 では `std::variant` という型が導入されました。
ひとつの `std::variant` 型の変数に、複数の型のオブジェクト値を格納できる機能です。
それらの型は virtual にする必要も継承関係を持つ必要もありません。
これは C 言語の `union` と同じ仕組みを、C++ の型に合わせて実現したものです。
Copyable class だけでなくて、Movable class のオブジェクトも格納できますので、使いどころはありそうです。
ただ、オブジェクトの型を見て適切に処理を分岐するコードは自分で書かないといけない点が、継承を使った多態とは違うところです。


### private 宣言について

メンバ変数やメンバ関数を private にすることによって、オブジェクトの外からアクセスできないようにすることをカプセル化と呼んだりします。
余計なものを見せないことで、オブジェクトの外と内の境界を、出来るだけ単純なものにし、メンテナンス性を担保する目的があります。
逆にいえば、むやみに private 化するのもまた意味がないということです。


```c++
struct A
{
private:
    int i_;
public:
    void set(int i) { i_ = i; }
    int get() const { return i_; }
};
```

 こんなコードを書くくらいなら、素直に `i_` を public にして直接アクセスすれば良いですよね。
入力をチェックする必要があるだとか、必ず加工してから出力するなどの理由があれば、メンバ変数を private に留める方が良い場合もあると思います。
メンバ関数について、外に見せる必要がない、その他のメンバ関数からのみ呼ばれる部品としてのみ機能するものは private にしておくべきでしょう。


