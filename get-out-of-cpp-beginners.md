# C++ 初心者からの脱出 v0.6

星野 喬 (著)

<a name="introduction"></a>

## はじめに

本ドキュメントは、C はある程度使ったことがあり、C++ を独学で学び始めた人が、やるべきではないことをいとも簡単にやってしまう状況を少し改善したいと思って書きました。
コンパイルは通るけれど、明らかにバグっている、メンテナンス性が悪い、性能面で問題があるコードを書かずに済むようになって欲しいという気持ちが込められています。

C++ は歴史が長いからなのか、とにかく仕様が複雑で大量にあります。
仕様を全部理解しないと C++ を使ってはいけないなんてことはありません。
脳味噌の容量は有限なのです。
C++ を牽引発展させていく人達はそういうわけにもいかないでしょうが、単に良いプログラムを書きたくて C++ を使おうとする我々にとっては、出来るだけ少ない知識で、必要十分に便利な機能を使いこなすのが理想です。
逆に、仕様で許されているからといって、やって良い、やるべき、とはならないことが多いのが初心者にとって辛いところだと思います。

本ドキュメントは C++ をまったく書いたことがない人向けではありませんので、網羅性についてはあまり重視していませんし、キーワードをいちいち説明していないこともありますので、適宜ご自分で調べてください。
本ドキュメントでは、何故そう書くか、何故そうすべきなのかについて、特に私が強く思っていることを書きます。
もちろん、全ての C++ プログラマが同意するような完璧なものではないと思いますが、私の C++ コードを書いたりレビューしたりのつたない経験から得たひとつの解釈ではありますので、参考にしてもらえれば幸いです。

以下の項目の一部または全部に「はい」と答えてしまう人は、本ドキュメントを読むべきだと思います:

- 動的メモリ確保といえば、`malloc` か `new` を使ってやるものだ。
- RAII という言葉を聞いたことがない、聞いたことあるけどよく分からない。
- 変数のスコープや寿命、所有や借用を意識してコードを書いていない。
- ポインタと参照の違いが良く分からない。
- `T&` と `T&&` の違いが良く分からない。
- const を使ったことがない、あまり使わない、その良さが良く分からない。

本ドキュメントでは、主に C++11 でサポートされる機能を対象にします。
場合によっては C++14、 C++17、C++20 について言及します。
サンプルコードは、比較的最近の GCC もしくは Clang でコンパイルできることを確認していますが、include 宣言などを省略したりしているので適宜追加してください。

C 言語はある程度使ったことがある人を対象にしていますので、[C FAQ](http://www.kouno.jp/home/c_faq/c_faq.html) を眺めて復習してきてください。
C++ のオンラインマニュアルとしてオススメなのは、[cppreference](https://en.cppreference.com/) です。
日本語であれば [cpprefjp](https://cpprefjp.github.io/) を挙げておきます。
サンプルコードを書いて実行してみたり、コンパイラによって出力されるアセンブラコードやバイナリコードを見てみることをオススメします。
さらに詳しい挙動を知りたい場合は、C++ 標準のドキュメント([ここ](https://en.cppreference.com/w/cpp/links)にリンクがまとまっています)や、コンパイラのドキュメント([GCC](https://gcc.gnu.org/onlinedocs/)、[Clang](https://clang.llvm.org/docs/UsersManual.html))が参考になるでしょう。
C++ と直接関係はありませんが、実際の挙動については CPU のインストラクションや、OS のシステムコールなどについて調べる必要があるかも知れません。


<a name="table-of-contents"></a>
## 目次

[TOC]


<a name="struct-and-class"></a>
## C++ クラスと C 構造体の違い

C++ クラスは C 構造体の概念を内包しています。
[POD](https://en.cppreference.com/w/cpp/named_req/PODType) (Plain Old Data) class は C 構造体として C 関数に渡せる、`memcpy` でコピーできるなどの特徴を持ちます。
C++11 では、POD の定義が [standard-layout](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType) class と [trivial](https://en.cppreference.com/w/cpp/named_req/TrivialType) class というふたつの概念で表現されるようになり、C++20 では POD よりも後者の概念が主体的に扱われるようになります。
Standard-layout class は C 構造体として C 関数に渡せることを、trivial class は `memcpy` でコピーできることを念頭に定義がされています。
C 言語で使っていた `struct` の機能以上のものを使っておらず、メンバ変数もそうであるクラスは、間違いなく standard-layout かつ trivial なので安心してください。
逆にいえば、C 構造体として C 関数に渡してはいけなかったり、`memcpy` してはいけないクラスが存在するということです。
例えば、仮想関数をメンバに持つクラスは standard-layout でも trivial でもありません。
仮想テーブルのような隠れたデータを持つことがあり、`memcpy` するとデータが破壊されることがあります。


<a name="cstr-dstr"></a>
### コンストラクタとデストラクタ

C++ クラスはコンストラクタとデストラクタを持ちます。
コンストラクタはオブジェクトの初期化時に実行されるコードで、デストラクタは開放時に実行されるコードです。
これらは返り値を持ちません。
コンストラクタはシグネチャ(簡単に言うと仮引数の数や型)が異なれば複数定義できますが、デストラクタは引数を持たないものひとつだけです。
特殊なコンストラクタとして、デフォルトコンストラクタ (`T()`)、コピーコンストラクタ(`T(const T&)`)、ムーヴコンストラクタ(`T(T&&)`) があります。


<a name="member-function"></a>
### メンバ関数

クラスにはメンバ関数を定義できます。
メンバ関数は、そのクラス特有の処理を行うときに便利です。
また、メンバ関数の名前が、同じクラス内のメンバ関数以外からは見えないというメリットや、C 構造体の要素に相当するメンバ変数、とりわけ非公開のメンバ変数に直接アクセスできるメリットがあります。
これはメンバ関数やメンバ変数のスコープがクラススコープであるからです。
メンバ関数の引数にはクラス外部のもののみ渡せばよいので、シグネチャがスッキリし、分かりやすくなります。

ある処理をグローバル関数とメンバ関数のどちらにすべきか悩んだ場合は、それらのメリットデリットを天秤にかけて決めてください。
非公開メンバ変数にアクセスする必要がないのにメンバ関数にする必要はあまりないと思いますが、迷った時は使いやすい方、メンテナンスしやすい方を選ぶのが良いでしょう。


### オーバーロード

[オーバーロード](https://en.cppreference.com/w/cpp/language/overload_resolution)とは、同じ名前の関数でも仮引数の数や型が異なれば別の関数として扱うことのできる仕組みです。
あるクラスでコンストラクタを複数定義したときもオーバーロードしています。
何が区別され、何が区別されないかについて、厳密な条件はかなり複雑です。
簡単に確認する方法は、実際に複数の同じ名前の関数やテンプレートを定義してみて、コンパイルエラーになるかどうかを見ることです。
また、ある引数リストを与えたときに、どのシグネチャが選ばれるのかも、試してみるのが一番早いと思います。
避けられない場合を除き、オーバーロード関数をたくさん定義するのは良いこととはいえません。
どのシグネチャが選ばれるか分かりづらいと可読性やメンテナンス性が落ちるのはいうまでもありません。
複雑なものは分かりにくいのです。
同じ名前にする意味があるのかどうかを自問自答してください。
別名でも問題ないのなら別名にしてください。
迷ったら別名にすべきです。

オーバーロードを使う典型的な例をいくつか挙げておきます:

1. コンストラクタ
2. メンバ関数の const 版と non-const 版
3. const lvalue 参照を受けとるコピー版と、rvalue 参照を受けとるムーヴ版
4. 異なる型を扱うが同じ操作を意味する関数、演算子

最後の例は、テンプレート関数を定義することで、オーバーロードされた複数の関数をまとめて自動生成することも多いと思います。


<a name="inheritance"></a>
### 継承の使いどころ

継承は、本当にすべきかどうかをよく考えてからにしてください。
`is-a` と `has-a` の違いについて調べてください。
昨今の C++ で継承を利用すべきケースは初心者の方が思っているよりもかなり限られます。
不用意な継承の使用は、メンテナンス性の悪いコードへの第一歩となります。

仕方なく継承を使うケースとして、多態 (polymorphism) が挙げられます。
多態とは、ここでは、基底クラス型のポインタに、複数の派生クラス型のオブジェクトポインタを格納し、同じメンバ関数呼び出しでもオブジェクトの実際の型によって異なる挙動をさせる使い方を指します。
多態させるメンバ関数と、デストラクタは、 virtual メンバ関数にすることを忘れないでください。
C 言語だと `union` を使って行うような処理ですが、その場合は自分で型を判定できる要素を用意し、それを用いて条件分岐して挙動の変化を実現します。
virtual メンバ関数を定義してしまうと、オブジェクトは vtable という構造を持ち、関数呼出時に型によって処理を分岐するようになるため、オーバーヘッドが発生しますので注意が必要です。
逆に、virtual キーワードを指定しない場合、あるコードにおいて用いられる型は静的に(コンパイル時に)決まってしまうため、同じ名前のメンバ関数だけれど、オブジェクトの実際の型によって中身が異なるものを実行するという目的は達成できないでしょう。
以下の例に挙動の違いを示します。


```c++
#include <cstdio>
#include <memory>

struct A
{
    virtual void f1() { :: puts("A::f1"); }
    void f2() { ::puts("A::f2"); }
    virtual ~A() {}
};

struct B : A
{
    void f1() { ::puts("B::f1"); }
    void f2() { ::puts("B::f2"); }
    void f3() { ::puts("B::f3"); }
    ~B() {}
};

int main()
{
    A* p = new B;
    p->f1();  // B::f1 が表示される
    p->f2();  // A::f2 が表示される
    //p->f3();
    dynamic_cast<B*>(p)->f3();  // B::f3 が表示される
    ((B*)p)->f3();  // B::f3 が表示される
}
```
`A` のポインタであったとしても、`f1()` は virtual メンバ関数なので、多態に相応しい挙動をし、`B::f1()` が呼ばれます。
しかし、virtual ではない `f2()` は、`A*` の型だけ見てコンパイル時に呼ぶ関数を決定しますので、`A::f2()` が呼ばれます。
`f3()` に至っては `A` で定義されてないのでキャストなしでは呼ぶことすらできません。
それが `B` のオブジェクトであることを確信できる場合のみ `dynamic_cast` を使えますが、それはすなわち、`p` が指しているオブジェクトの型が `B` であるかどうかを判別する明示的な条件分岐を必要とするわけです。


また、継承を使うときに気をつけなければいけないこととして、一般にデストラクタの virtual 化が必要になります。
以下は悪い例です:

```c++
// 悪い例
struct A
{
  ~A() {}  // non-virtual destructor
};

struct B : A
{
   int *p;
   B() : p(new int(0)) {}
   ~B() { delete p; }
};

int main()
{
    A *a = new B();
    delete a;  // ~A() が呼ばれ、~B() は呼ばれないので、メモリリーク
}
```

この例では、`~A()` が virtual ではないので、`A*` 型の変数 `a` から `B` 型のオブジェクトを指しているとき、`delete a;` は `~A()` のデストラクタのみを呼んでしまい、メモリリークします。
`~A()` に virtual を指定しておけば、ポインタの型 (`A`) ではなく、実体の型 (`B`) のデストラクタを呼んでくれます。
`~B()` だけに virtual を指定しても `~A()` は自動的には virtual にならないため、やはりメモリリークしてしまうのが少しややこしいです。
`virtual` は子孫には伝搬しますが、先祖には伝搬しませんのでご注意ください。

Mix-in は、virtual メンバ関数を使わずに、派生型でメンバ変数を新たに定義せず、メンバ関数だけを増やす手法です。
派生型のデストラクタでは何もする必要がなく、基本型のデストラクタだけ呼ばれれば良いため、virtual デストラクタがなくても問題ありません。
Mix-in は vtable を必要とするクラスが持つデメリットの影響を受けないので気軽に使えますが、使いどころは限られます。

C++17 では `std::variant` という型が導入されました。
ひとつの `std::variant` 型の変数に、複数の型のオブジェクト値を格納できる機能です。
それらの型は virtual にする必要も継承関係を持つ必要もありません。
これは C 言語の `union` と同じ仕組みを、C++ の型に合わせて実現したものです。
Copyable class だけでなくて、Movable class のオブジェクトも格納できますので、使いどころはありそうです。
ただ、オブジェクトの型を見て適切に処理を分岐するコードは自分で書かないといけない点が、継承を使った多態とは違うところです。


<a name="private-declaration"></a>

### private 宣言について

メンバ変数やメンバ関数を private にすることによって、オブジェクトの外からアクセスできないようにすることをカプセル化と呼んだりします。
余計なものを見せないことで、オブジェクトの外と内の境界を、出来るだけ単純なものにし、メンテナンス性を担保する目的があります。
逆にいえば、むやみに private 化するのもまた意味がないということです。


```c++
struct A
{
private:
    int i_;
public:
    void set(int i) { i_ = i; }
    int get() const { return i_; }
};
```

 こんなコードを書くくらいなら、素直に `i_` を public にして直接アクセスすれば良いですよね。
入力をチェックする必要があるだとか、必ず加工してから出力するなどの理由があれば、メンバ変数を private に留める方が良い場合もあると思います。
メンバ関数について、外に見せる必要がない、その他のメンバ関数からのみ呼ばれる部品としてのみ機能するものは private にしておくべきでしょう。


<a name="variables"></a>

## オブジェクトと変数

ある型のデータを入れることを想定した連続メモリ領域のことを[オブジェクト](https://en.cppreference.com/w/cpp/language/object)と呼びます。
オブジェクトについた名前を変数といいます。

オブジェクトには対応する型の具体的なデータ、すなわち値が格納されます。
C++ における変数は値型変数、ポインタ型変数、参照型変数の 3 種類があります。
値型変数は、対応した型の値が格納されます。
算術型 (arithmetic type) の値 (int 型の 1 や float 型の 2.3 など) や、クラス型であればその具体的なインスタンスオブジェクトの内容です。
ポインタ型変数は、オブジェクトの位置を表わすメモリアドレスを格納します。
メモリアドレスが格納されるメモリ領域もオブジェクトとみなします。
つまり、ポインタ型変数にとっての「値」はメモリアドレスということになります。
例えば `int** a;` は 「`int` オブジェクトを指しているポインタ型オブジェクト」を指しているポインタ型オブジェクトに `a` という名前がついていることになり、二段階の関節参照を意味しています。
参照型変数は既に存在するオブジェクトの別名という扱いです。
型についての詳しい分類が[ここ](https://en.cppreference.com/w/cpp/language/type)に書いてあります。
その説明によればオブジェクト型はポインタ型を含みますが、参照型を含みません。
関数の参照型引数やクラスの参照型メンバ変数はアドレスを格納しますので、これらの場合はポインタと大体同じものだと思ってもらって構わないと思います。

プログラムから見える、オブジェクトが配置されるメモリ領域には、静的領域、スタック領域、ヒープ領域の 3 つがあります。
グローバル変数やファイル内ローカル変数は静的領域に、関数内ローカル変数はスタック領域にデータが格納されます。
関数呼び出しの度に、呼び出し側のローカル変数を保持したままで新しいローカル変数用の領域を用意する必要があるため、スタックは伸びます。
逆に、関数呼び出し完了の度にそのローカル変数は寿命を迎えて不要になるのでスタックは縮みます。
ヒープ領域にはオブジェクトを配置できますが、それを指して使うには、ポインタ型変数や参照型変数が必要になります、つまりグローバル変数やローカル変数から辿れるようになっていないと使えません。
オブジェクトが配置される領域によって、スタックオブジェクト、ヒープオブジェクトなどと区別することがあります。


### オブジェクトのメモリイメージ

C++ を扱うならば、是非オブジェクトのメモリイメージを意識してもらいたいです。
例えば、以下のようなクラス `A` を考えます。

```c++
struct A
{
    int i;
    int j;
};
```
`A` のオブジェクトは、コンパイラやそのオプション次第で変わり得ますが、通常 4 + 4 = 8 bytes のデータを持つ連続メモリ断片となります。
つまりコンパイル時に型のサイズ `sizeof(A) == 8` が決まります。
連続メモリ断片と呼んでいるのは、プロセスメモリ空間上で、ひとつのアドレス範囲で表現できるメモリ領域ということです。
CPU アーキテクチャが x86_64 などの little endian であれば、たとえば、`int` 型の `1` は、`0x01`, `0x00`, `0x00`, `0x00` という順序で 1 byte ずつ計 4 bytes 配置されます。
算術型など CPU がそのまま扱える型は、どのような値がどのようなバイト列になるのか、CPU によってフォーマットが決まっています。
一般に異なるアーキテクチャの CPU 同士では互換性はありませんが、`int` などの基本的な型は big endian か little endian くらいの違いしかないことがほとんどです。


以下のクラス `B` はどうでしょうか。

```c++
struct B
{
    int i;
    int j;
    A *a;
};
```
`B` のオブジェクトは 64bit アーキテクチャでは通常 4 + 4 + 8 = 16 bytes のデータを持つメモリ断片となります。
つまり `sizeof(B) == 16` ということです。
ポインタ型メンバ変数 `*a` は別のメモリ領域にある `A` 型オブジェクトを指し得ます。
ひとつの連続メモリ断片としての `B` のオブジェクトには `*a` が指す `A` 型オブジェクトのアドレスは含んでいても、オブジェクトの値そのものは含まれないことに注意してください。
それは一般に、離れたアドレス上に存在する別の連続メモリ断片です。
よく連続メモリ断片としてのオブジェクトを四角形で、ポインタを矢印で表してその構造を図示したりします。
`a` が `nullptr` でない `B` オブジェクトを図示すると、四角形が 2 つで、それが矢印ひとつで結ばれている図となります。
文脈によっては、ポインタ型や参照型のメンバ変数が指しているオブジェクトも含めて広い意味でひとつの「オブジェクト」と考える場合もあります。


<a name="scope-and-lifetime"></a>
### スコープと寿命

[スコープ](https://en.cppreference.com/w/cpp/language/scope)とは、変数にアクセス可能なコード範囲のことです。
スコープにはいくつか種類がありますが、代表的なものとして、ブロックスコープ、関数スコープ、関数パラメータスコープ、クラススコープが挙げれらます。
大雑把ではありますが `{}` で囲まれた領域はスコープと思って下さい。
変数の[寿命](https://en.cppreference.com/w/cpp/language/lifetime)は変数が宣言されてから、対応するスコープの終わりまでです。
なぜスコープや寿命を意識する必要があるといえば、スコープの終わり、寿命が尽きた変数が指しているオブジェクトのデストラクタが暗黙的に呼ばれるからです。
我々の思い通りにリソースをコントロールするために、我々は変数の寿命がいつ来るかについて知っておく必要があります。
昔の C と違って、C++ ではブロックや関数の途中でも変数が宣言できますので、必要なときに宣言することで、スコープを可能な限り小さくすることができますし、メンテナンスの観点からもそうすべきです。


注意点として、`new` で確保したヒープオブジェクトのアドレスを生ポインタに格納し、その変数が寿命を迎えると、それが指していたヒープオブジェクトはリークします。
ヒープオブジェクトに元々寿命はないのです。
オブジェクトのリークとは、そのオブジェクトはもはや誰にも使われないのに、期待を裏切って開放されずにメモリを占有し続けてしまうことをいいます。
これは明らかにバグですね。
何故リークしてしまうのかといえば、生ポインタオブジェクトはデストラクタを持たず、それが指しているヒープオブジェクトを開放する責任がないからです。
明示的にヒープオブジェクトを所有させ、変数の寿命と共に `delete` させたいときはスマートポインタを使いましょう。
スタックオブジェクトは対応する関数呼び出しが完了すれば自動的にスタックが縮むことにより使っていたメモリが再利用可能な状態になりますので、ヒープオブジェクトのようなリークの心配はいりません。


関数によって値返ししたり、コンストラクタを直接呼び出して作ったオブジェクトなどは一時オブジェクトと呼ばれますが、一時オブジェクトの寿命はその使われ方によって変わります。
通常、一時オブジェクトの寿命はそれを含む文が終わるまでですが、const lvalue reference または rvalue reference で受けたときは、その変数のスコープまで寿命が延びます。
ここで注目している一時オブジェクトはあくまでスタックオブジェクトで、ヒープオブジェクトではないことに注意してください。


関数が値返しであるならば、返されるオブジェクトが関数内ローカルオブジェクトや一時オブジェクトだったとき、関数の返り値を受けとる変数にコピーやムーヴされ、それ自身は関数の終わりで寿命が来てデストラクタが呼ばれることが想定されます。
C++ では条件にもよりますが最適化によってこのコピーやムーヴが省略されます。
つまり、格納される変数は関数内のものから呼出側のものへと変わりますが実質的にオブジェクトの寿命が延びるわけです。
C++17 ではこの返り値関連の最適化を含む [copy elision](https://en.cppreference.com/w/cpp/language/copy_elision) が義務化されました。


<a name="variable-initialization"></a>

### 初期化

オブジェクトの[初期化](https://en.cppreference.com/w/cpp/language/initialization)についても気をつける点があります。
原則として変数宣言や領域確保から初期化までのタイムラグはゼロか、ごく短かくなるようにしましょう。
算術型などでは C 言語と同じように、`int i;` のように初期化なしで宣言した場合は内容が不定になります。
ヒープオブジェクトの場合も同様で、`int* i = new int;` と書くと不定となります。
グローバル変数や static 変数など静的領域に確保されるものは `static int i;` などと宣言すると[ゼロに初期化](https://en.cppreference.com/w/cpp/language/zero_initialization)されます。
算術型をメンバ変数に持つクラスでも、コンストラクタの初期化子を使って初期化しないと不定になります。
たとえば `struct A { int i; };` における `i` は `A` の初期化後も不定です。`struct A { int i; A() : i() {} }` で初期化子を使うと A の初期化によって`i` は  `0` となります。
そのような細かい知識を知らなくても安全なプログラムを書くために、明示的な初期化を心がけることをオススメします。
明示的な初期化とは以下のような操作です:

1. 宣言だけでは初期化されない型は初期値を明示的に与えて宣言/確保する。
例: `int i = 0;`、`int* i = new int(0);`
2. 宣言だけでは初期化されない型をメンバ変数に持つクラスは、コンストラクタの初期化子で明示的に値を与える。
例: `struct A { int i; A() : int(0) {} };`
3. メンバ変数の初期化が保証されていない型を使う場合は、与えられた手段で宣言/確保後出来るだけ速やかに初期化する。
必要があれば自動で初期化を行うラッパークラスを作る。


明示的に初期値を与えたくない場合があるとすれば、それはコピーや計算結果の代入など他の手段で初期化する予定で、最初に `0` などを設定するのは無駄であり、性能に影響する、というケースでしょうか。
分かって使う分には問題ありませんが、メンテナンス性の上で、不定な値にアクセスするリスクがあるという認識は持っておいてください。
また、他人の書いた変数宣言やクラス定義のメンバ変数とコンストラクタを見て、宣言/確保時に不定なのか不定でないのかを判断するクセがつくと良いと思います。


C++11 からのユーザー定義型オブジェクトの初期化に関する注意点としては、`A a;` のような何も指定しない初期化 (default initialization)、`()` による初期化 (direct initialization)、 `=` による初期化 (copy initialization) に加えて、`{}` による初期化 (list initialization) も使えるようになったことです。
Direct initialization はコンストラクタに引数を与えて初期化するごく普通の初期化方法です。
Copy initialization はコピーコンストラクタやムーヴコンストラクタを使う初期化です。
List initialization はコンテナ型のオブジェクトにおいて `std::initialization_list<T>` を引数とするコンストラクタを用意しておいて、同じ型の要素を並べて初期化に用いるのが典型的な使い方のようです。


<a name="having-and-borrowing"></a>
### 所有と借用

C++ で明確に定義されているわけではないと思いますが、プログラムを設計実装する上で重要な概念だと思うので、ここで、所有と借用について説明しておきます。

所有とは、所有者が、所有する対象リソースの開放に責任を持っていることを指します。
所有の関係として考えられるのは、変数とそれが指しているオブジェクトだったり、オブジェクトとそれが管理しているメンバ変数などのリソースだったりします。
あるリソースがあったとき、それを開放するのはひとりだけですから、明示的にせよ潜在的にせよ、任意のオブジェクトについて、その所有者は原則ひとりだけということになります。
C++ においては、RAII を使ってコンストラクタでリソースを確保し、デストラクタで開放するクラスを設計した場合、そのインスタンスオブジェクトは、まさに当該リソースを所有していると言えるでしょう。
値型変数は、寿命が来たときにそれが指しているオブジェクトのデストラクタを呼ぶことから、それを所有していると言えるでしょう。
自分でリソースを確保したわけでなくても、他のオブジェクトからムーヴされたリソースがあって、それを自分のデストラクタで開放する必要がある場合、そのオブジェクトは、当該リソースを所有していると言えるでしょう。
また、オブジェクトはそのメンバ変数(が指しているオブジェクト)を所有しているといえるでしょう。
*has-a* 関係と言われるわけですし、自身のデストラクタ呼び出し後、メンバ変数のデストラクタが呼ばれるわけですから、開放に責任を持っていると言えるわけです。
さらに、生ポインタや参照が指しているヒープオブジェクトについて考えてみましょう。
ポインタや参照はあくまでオブジェクトを指しているだけですし、複数のポインタや参照がひとつのオブジェクトを指していることもあります。
しかし、誰かがオブジェクトを開放しなければ、それはリークしてしまうわけなので、誰かが開放に責任を持っていることが期待され、潜在的であったとしても所有者がひとりいると考えることができます。


借用とは、自分は所有者ではないけれど、対象のオブジェクトやリソースを指していて使う行為を指します。
C++ においては、ポインタ型変数や参照型変数とそれが指しているオブジェクトが、多くの場合、借用関係にあたると考えられます。
先程の例で、複数のポインタがひとつのヒープオブジェクトを指しているとき、ひとりは所有者で、残りは借用者というわけです。


所有と借用の例で分かりやすいのが `std::unique_ptr` でしょうか。
以下に例を示します:

```c++
{
    A* b0, b1;
    {
        std::unique_ptr<A> a0(new A);  // a0 が所有者
        b0 = a0.get();   // b0 は借用者
        std::unique_ptr<A> a1(std::move(a0));  // a0 から a1 に所有権が移動
        // a0 には nullptr が入っている
        b1 = a1.get();   // b1 は借用者
        // b0 も b1 も a1 と同じヒープオブジェクトを指している。

    }  // a0 は nullptr を指しているので何もしない。a1 のデストラクタでヒープオブジェクトを開放。
    // b0 および b1 は dangling pointer になる
}
```

RAII パターンは、リソースの寿命を変数の寿命と合わせることで、所有者であることを明確にする役割があると思います。
ある変数が、あるリソースを唯一指している状況にも関わらず、その開放に責任を持っているという自覚なしにコードを書けば、リソースリークしやすくなってしまいます。
また、借用者である変数が、その所有者よりも寿命が長いとき、その指している先が不正なメモリ領域である状態が発生します (dangling pointer/reference)。
それにアクセスしてしまうとセグメンテーションフォールトなど不正な動作をします。
すなわちバグです。


バグの少ないコードを書くために、所有者と借用者の区別をしっかりとつけて、所有者はリソースを責任をもって開放すること、所有者よりも借用者の寿命が長くならないように心がけましょう。
C++ では実際の開放はほとんどの場合デストラクタに任せれば良いので、専ら気にすべきなのは dangling pointer/reference ですね。
Rust などでは所有の概念を言語機能として持ち、プログラマに強力な制約を課してくるようですが、C++ はあくまでそれを助ける機能が存在するという印象です。
自由には責任が伴う、ということですね :)


<a name="memory"></a>
## メモリ

<a name="new-and-delete"></a>
### new と delete

C 言語だとヒープメモリは `malloc` 関数を使って確保し、`free` 関数を使って解放するのが一般的です。
`malloc`/`free` 関数は C++ でも使えますが、それとは別に `new` 演算子と `delete` 演算子が用意されています。
`new`/`delete` はヒープオブジェクトの確保と開放を行う操作で、ヒープメモリの確保解放だけではなくコンストラクタ/デストラクタの呼び出しもするという点が `malloc`/`free` とは異なります。

最も大事な点は、`new` や `delete` を素で呼んではいけないことです。
要するに以下のようなコードを書いてはいけません:

```c++
{
    A *p = new A;
    // p を使った操作
    delete p;
}
```

なぜいけないのか。
このようなコードを書くと我々はメモリリークするバグをいとも簡単に埋めこんでしまうからです。
メモリを確保してから開放するまでの間に例外が飛ぶ可能性を忘れていたり、開放を忘れて `return` などしてしまいます。
 `malloc` や `new` で確保したヒープメモリやヒープオブジェクトは、スマートポインタを使って管理するか、管理のための専用ラッパークラスを定義すべきです。
C 言語では注意深くコードを書かないとすぐにメモリリークしますが、C++ では上記の注意を守っていれば、まずリークしません。
RAII がメモリを含むリソースのリークから我々を守ってくれるからです。


<a name="raii"></a>
### RAII によるリソースリークの防止

[RAII](https://en.cppreference.com/w/cpp/language/raii) とは、*Resource Acquisition Is Initialization* の略で、リソースの寿命をオブジェクトの寿命に合わせることで、リソースリークを防ぐことができる手法です。
具体的には、リソースの確保をコンストラクタで行い、開放をデストラクタ内で行います。
例外が飛んでも対応するスコープを抜けて寿命が尽きたオブジェクトのデストラクタは必ず呼ばれるので、開放し忘れることがないという仕組みです。
リソースとして、メモリだけでなく、ロック、ファイルディスクリプタ、ネットワークコネクション、などなど様々なものを対象に出来ます。
特に、長時間動作するサーバープロセスなどのプログラムでは、プログラムが使う全てのリソースに対して RAII を使うことを強くオススメします。
必要があれば自分でラッパークラスを作ってください。
これを徹底するだけで、我々は自動的にほぼリソースリークしないプログラムを手にいれることができます。
例えば以下のコードを見てください:

```c++
void bad_code()
{
    A* p = new A;
    try {
        // 例外を投げるかも知れない操作
        delete p;
    } catch (std::exception&) {
        delete p;
        throw;
    }
}

struct SafeHeapA
{
    A* ptr;
    SafeHeapA() : ptr(new A) {}
    ~SafeHeapA() noexcept { delete ptr; }
};

void good_code()
{
    SafeHeapA s;
    // 例外を投げるかも知れない操作
}
```

`bad_code()` では、ヒープオブジェクトを作成して `p` から指すようにした後、常に例外発生の可能性に気を配ってコードを書き、最後にヒープオブジェクトを開放する責任が `bad_code()` 関数に生じます。
しかし、`good_code()` のように RAII に従った `SafeHeapA` というラッパークラスを用意すれば、例外が投げられても `s` のデストラクタは必ず実行され、メモリリークは起きないですし、コードも読みやすくなります。


デストラクタ自身は例外を投げられないので、リソース開放処理中に発生した例外を検知、処理したい場合は、リソース開放を実行するメンバ関数(`close()` など) を用意して、`try-catch` 節内で明示的に呼び出す必要があります。
そのようにクラスを設計したとしても、`close()` を明示的に呼び忘れたときのために、デストラクタでも `close()` を呼ぶようにして、万全を期すアプローチが有効でしょう。
もちろん `close()` は複数回実行しても問題ないように設計するか、フラグ等を用いて実質一度しか呼ばれないようにしておく必要はあります。


```c++
struct A
{
    bool closed_;
    Resource resource_;
    A() : closed_(false), resourece(open_resource()) {}
    ~A() noexcept try {
        close();
    } catch (...)
    }
    void close() {
        if (closed_) return;
        close_resource(resource_);
        closed_ = true;
    }
};
```



<a name="smart-pointers"></a>
### スマートポインタ

C++11 以降で `#include <memory>` によってスマートポインタが使えます。
`std::unique_ptr` と `std::shared_ptr` です。
これらはヒープオブジェクトを RAII に従って管理するためのクラスです。
簡単に説明すると、`new` 演算子で確保されたオブジェクトをスマートポインタに入れて管理すると、スマートポインタの寿命が来たときに、自動的にデストラクタが呼ばれ、その中で `delete` が呼ばれて指していたヒープオブジェクトが開放されます。


```c++
{
    std::unique_ptr<A> p(new A);
}  // p の寿命。p が管理していた A 型のヒープオブジェクトは p のデストラクタによって自動的に delete される。

```

スマートポインタは、変数の寿命とヒープオブジェクトの開放タイミングを一対一対応させ、開放忘れを防いでくれます。
我々がコードを書くときに、特に何も注意しなくても、関数内ローカル変数の寿命はブロックの終わりで尽きることが多いですから、注意深く `delete` を実行するコードを手動で書くのに比べて圧倒的に安全です。


`std::unique_ptr` と `std::shared_ptr` は、オブジェクトをひとつの変数で占有するか、複数の変数で共有するかよって使い分けますが、`std::shared_ptr` を使う場面は多くないでしょう。
ありがたいことに、生ポインタに比べて `std::unique_ptr` を使うために追加で必要なオーバーヘッドはありません。
64bit アーキテクチャの場合、`sizeof(std::unique_ptr<A>)` は  8 です。
追加のコストなしに使えるので、ヒープオブジェクトを自分で確保する必要が生じた場合、ほとんどの場面で `std::unique_ptr` を使うべきです。
一方、`std::shared_ptr` はオーバーヘッドなしとはいかず、ヒープオブジェクト毎にコントロールブロックを保持管理する必要があり、それへのポインタを追加で持つため、`sizeof(std::shared_ptr<A>)` は大抵 16 です。


`std::unique_ptr`  はコピーできませんがムーヴできます。
一時的に関数などに渡して使う場合はムーヴせずに `std::unique_ptr` それ自身の lvalue 参照渡しもしくは中身のポインタを生で渡せば良いですし、ムーヴを使うことで他の変数や rvalue 参照渡しされた引数などに管理を移譲することもできます。
所有と借用の概念については別途説明しますが、`std::unique_ptr` が所有者で、ヒープオブジェクトを指している生ポインタや参照を持っているオブジェクトは借用者だと考えれば、ヒープオブジェクトの開放に責任を負っているのは所有者で、所有者の寿命が一番長くなるようにするか、所有者の寿命がもうないかもしれない場面で借用者がアクセスを避けるように気をつかえば、問題にはなりません。

スマートポインタを使いづらい場面があるかも知れません。
生ポインタを使うことは確かに危険を伴いますが、利便性と安全性のトレードオフをうまく取るのが良い選択です。
オブジェクトの寿命を意識し、ポインタの dereference (間接参照によるアクセス) を使うのはオブジェクトが生きている間だけ、という鉄則を守ってください。
プログラムの中で、そのような特別なケアをしなければならないオブジェクトはごく一部なので、気をつかうのもその周辺のコードだけで済むのは有り難いことです。
問答無用で全てのヒープオブジェクトの寿命を手動管理させられる C の世界に比べれば天国です。

`std::shared_ptr` の使いどころがあるとすれば、対象のヒープオブジェクトを複数人が指した状態で使いたいが、誰が一番寿命が長いのか自明ではなく、かつリファレンスカウント方式の garbage collection を採用したいケースに限られるでしょう。
たとえばマルチスレッドプログラムで、ふたつのスレッドがあるヒープオブジェクトを `std::shared_ptr` で指していて、どちらかが先に寿命を迎えるか分からないようなときです。

ここまで説明しておいてなんですが、同一型の複数のオブジェクトをまとめて管理したいときは、STL のコンテナライブラリが役に立ちます。
多くの場合、自分でヒープオブジェクトを確保してスマートポインタで管理しなくても、コンテナを使えば事足ります。
コンテナはその内部で要素を格納する領域をヒープメモリから確保し、寿命が来たらデストラクタで必要な開放処理を行います。
それらの挙動はもちろん RAII に従っています。


### 動的確保した配列より std::vector

配列の動的確保をするのにも `new` 演算子を使えますが、ほとんどの場合代わりに `std::vector` を使うべきです。

たとえば `int` 型の配列を動的に確保して使うことを考えてみましょう。
`new` を使う場合は、次のように書きます。

```c++
{
    // size_t n;
    std::unique_ptr<int[]> v(new int[n]);
    // v を使う。サイズが n であることは別途覚えておく必要がある。
}   // std::unique_ptr<int[]> のデストラクタが delete[] を呼ぶ。

```
配列 `new` を用いて確保したメモリはコンパイル時に要素数やサイズが決まる配列とは違うことに注意が必要です。
配列 `new` 演算子は先頭要素へのポインタを返すため、サイズ情報は自分で管理する必要があります。
各要素は class 型の場合デフォルトコンストラクタで初期化されますが、int など算術型の場合は `new int[n];` では初期化されず、`new int[n]();` でゼロ初期化されます。
デフォルトコンストラクタを持たない型の動的配列はこの方法では確保できません。

`std::vector` を使う場合は、
```c++
{
    std::vector<int> v(n);  // 内部的に連続するヒープメモリを確保
    // v を使う。v.size() でサイズも分かる。
} // std::vector<int> のデストラクタがヒープメモリを開放
```
と書きます。
デフォルトコンストラクタを持たない型でも、

```c++
{
    std::vector<A> v(n, A(arg0, arg1));
}
```
と書けば初期化できます。
ただ、このコンストラクタを使った場合、各要素は初期化後コピーされてしまうので算術型以外の要素だったり、`n` が大きいときに使うのはオススメしません。
少々手間ですが、
```c++
{
    std::vector<A> v;
    v.reserve(n);
    for (size_t i = 0; i < n; i++) {
        v.emplace_back(arg0, arg1);
    }
}
```
とすれば、ヒープメモリの確保は 1 回だけに抑えて、無駄なく要素毎に好きなコンストラクタを呼べます。
他にも `std::vector` は便利なメンバ関数を色々と供えていますので、是非使ってください。

`std::vector` を使うデメリットがあるとすれば、`std::vector` は要素を格納するヒープメモリ以外に見かけ上のサイズと実サイズの 2 つのデータを保持しているため、同一サイズの動的配列を大量に作るときは、それらがメモリ容量のオーバーヘッドになるかも知れないことでしょうか。
とはいえそのオーバーヘッドは一次元配列であれば無視できる程度だと思います。


二次元配列が作りたいなら、次のようにします。

```c++
size_t size0 = 10, size1 = 100;
std::vector<std::vector<int>> vv(size0);
for (size_t i = 0; i < size0; i++) {
    vv[i].resize(size1);
}
```
`resize` による実質的なメモリ確保操作を複数回実行するのが面倒ですね。
`new` を使う方法はさらに面倒なので省略します。
次元が増えていくと、`std::vector` を使ったとしてもどんどん面倒になるので、サイズ固定の多次元配列を動的に確保したいなら、ひとつの `std::vector` の一次元配列を多次元配列に見立て、アクセス用のメンバ関数を用意した方が良さそうです。

```c++
class TwoDimensionalIntArray
{
    const size_t s0_, s1_;
    std::vector<int> v_;
    TwoDimensionalIntArray(size_t s0, size_t s1) : s0_(s0), s1_(s1), v_(s0 * s1) {}
    int get(size_t i, size_t j) const {
        assert(i < s0_); assert(j < s1_);
        return v_[i * s1 + j];
    }
    void set(size_t i, size_t j, int value) {
        assert(i < s0_); assert(j < s1_);
        v_[i * s1 + j] = value;
    }
};
```
このようなクラスは STL にはないですが、そこらのライブラリには用意されていますので、それを使うのも手です。


<a name="alignment"></a>
### アラインメント

アラインメントとは、オブジェクトやメモリ断片の先頭アドレスが指定されたサイズの倍数になっていることを求める制約です。
C++11 以降では `alignas` キーワードでオブジェクトのアラインメントを制御することができます。
```c++
{
    alignas(64) int i;
    ::assert(uintptr_t(&i) % 64 == 0);
}
```
スタックオブジェクトの場合はこのように簡単に制御できます。
ヒープオブジェクトの場合は、C++17 以降であれば `alignof(T)` の値が考慮されます。
```c++
struct alignas(64) A
{
};

{
    A* a = new A;
    ::assert(uintptr_t(a) % 64 == 0);
}
```
`alignof(std:max_align_t)` より大きなアラインメント指定は実装依存らしいので、実際に確認してから使ってください。

64bit 環境において `malloc()` で保証される 8 bytes よりも大きな単位で、より柔軟にアラインメントサイズを設定してヒープオブジェクトを確保したい場合は、`std::aligned_alloc()` (C++17 以降) や、 `posix_memalign()` もしくは `mmap()` を使えます。
これらのヒープメモリを C++ オブジェクトとして振る舞わせたい、すなわちコンストラクタとデストラクタを呼びたいときはどうしたら良いでしょうか。
ひとつの手は、ラッパークラスを作って、そのコンストラクタ内でメモリを確保して placement new 演算子を呼び、ラッパークラスのデストラクタ内で元のクラスのデストラクタを明示的に呼んだ後に `free()` や `munmap()` を呼んでメモリを開放すれば良いです。

```c++
#include <cstdlib>
#include <new>

struct A
{
    A() { /* ... */ }
    ~A() { /* ... */ }
};

A* alloc_and_cstr(size_t alignment)
{
    void *p;
    if (::posix_memalign(&p, alignment, sizeof(A)) != 0) {
        throw std::bad_alloc();
    }
    try {
        return new(p) A;
    } catch (...) {
        ::free(p);
        throw;
    }
}

struct B0
{
    A *a0_;
    B0() : a0_(alloc_and_cstr(ALIGNMENT)) {}
    ~B0() {
        a0_->~A();
        ::free(a0_);
    }
};
```
`new(p) A;` が placement new 演算子を使って初期化する操作です。
Try-catch 節は `A` のコンストラクタが例外を投げるケースをカバーしています。


ヒープオブジェクトは出来るだけ早く `std::unique_ptr` に格納することをお薦めします。
`B0` はこのままでも動きますが、もしコンストラクタ内で例外が飛ぶような実装だった場合、`a0_` が指しているヒープオブジェクトはリークします。
```c++
struct B1
{
    struct Deleter {
        void operator()(A* a) { ::free(a); }
    };
    std::unique_ptr<A, Deleter> a1_;
    B1() : a1_(alloc_and_cstr(ALIGNMENT)) {}
};
```
`B1` はそのような場合でも `a1_` のデストラクタが呼ばれてリークは発生しません。

コンテナの要素をアラインメントさせたいときは、素直に要素型の定義で `alignas` を指定するのが無難です。
もしくは `B1` のような型を要素として格納するようにしましょう。
コンテナのカスタムアロケータを使ってアラインメントを実現しようとするのはお薦めしません。
何故なら `std::vector` や `std::deque` は先頭要素か一部の要素しかアラインされないし、`std::list` や `std::map` などでは内部で付加情報のついた型をアロケートするようになっていて、要素のアドレスがアロケートされたメモリのアドレスとずれるので、うまくいきません。



<a name="reference"></a>
## 参照

改めて説明しますが、ポインタ(ポインタ型変数)とは、ヒープオブジェクトやスタックオブジェクトのメモリ上の位置、すなわちアドレスをデータとして格納する変数です。
ポインタは C 言語でも使いますし、解説もたくさんありますので、これ以上はここで説明しません。

参照は、プログラミングをする上で実質的にポインタに似た性質を持つものであると見なして構いません。
C++ に慣れた人はポインタよりも参照を多用します。


<a name="reference-usage"></a>
### 参照の使い方

参照は、ポインタと同様に、あるオブジェクトを指しているだけですが、ポインタと違って、値型変数と同様の操作ができます。

`A` というユーザー定義型があったとします。

```c++
A a;  // normal variable
A& ref = a;  // reference variable
A* ptr = &a;  // pointer variable

ref.func();
ptr->func();  // ptr が nullptr だと不定動作

A* ptr2 = &ref;  // 参照変数のアドレスも取れる

// ref = nullptr; // 不可能
ptr = nullptr;
```

参照 `ref` は `.` 演算子でメンバにアクセスできますが、ポインタ `ptr` は、それが実在するオブジェクトを指しているときに限り `->` でアクセスする必要があります。
もしくは明示的に dereference して `(*ptr).func();` などとアクセスできます。
参照は、値型変数と同様に `&` でアドレスも取れます。
参照は、その宣言時に必ず初期化を必要とし、実在するオブジェクトを必要とするだけでなく、参照先を後から変更することもできません(再代入不可能)。
つまり、参照は常に初期化時に指定されたオブジェクトを指しています。
ポインタは宣言と初期化を分離できますし、代入によって自由に指すオブジェクトを変えることができますし、`nullptr` を格納できる点が異なります。
そうです、参照は `nullptr` を保持できません。
つまり、どのオブジェクトも指していない、という状態を表現できません。
表現力という点において参照はポインタに劣るのです。
だがそれが良いのです。
別の言い方をすると、参照は、dereference が保証されたポインタのように振る舞うとも言えます。


<a name="value-of-reference"></a>
### 参照の価値

ポインタよりも参照を使いたくなる典型的な例を以下に挙げます。
```c++
void func(A* p)
{
    if (p == nullptr) {
        // error 処理
    }
    // *p により A 型オブジェクトにアクセスできる。
}

void func(A& a)
{
    // nullptr チェック不要。a を値型変数のように扱って良い。
}
```
`void func(A& a)` は関数シグネチャを見れば `nullptr` を渡せないのは明らかで、内部での `nullptr` チェックが不要になります。
だから `func()` が、`A` の実体を必ず必要とする場合には、参照渡しをすべきです。
逆に、`nullptr` であることに意味を持たせる場合、例えば、「A のデータがない」という意味を持たせ、`func()` がそれを許容する、`nullptr` のときでも通常処理を行えるような場合は、ポインタ渡しの `void func(A* p)` を選択する意味があると思います。

メンバ関数がメンバ変数のポインタか参照を返したいと思ったときに、どちらで返すのが良いでしょうか。
これも関数の仮引数のときと同じ考え方で決めれば良いと思います。
つまり、ポインタで返す場合は、`nullptr` が返ることに意味が持たせてある場合のみにすべきです。
呼出し側は `nullptr` が返ったときでも通常処理を行うような場合です。
逆に` nullptr` が絶対に返らないなら、ポインタではなく参照を返すインターフェースにすべきです。
そうでないと、呼出し側は絶対に返らないはずの `nullptr` が返るかも知れないと思って無駄な分岐処理を書いてしまうかも知れません。
少なくとも関数シグネチャを見ただけでは `nullptr` が返らないことは分かりません。
参照返しのインターフェースならそれは一目瞭然ですね。

参照渡しとポインタ渡し、参照返しとポインタ返しの使い分けをしっかりすることが、
C++ で書かれたコードの可読性、メンテナンス性に大きな影響を与えると思います。


### コピーセマンティクス

コピーセマンティクスの目的は、オブジェクトを安全にコピーできるようにすることです。
一般に、オブジェクトがコピー可能 (Copyable) であるときは、コピーコンストラクタとコピー代入演算子が定義されていて、それらの挙動はコピーであること、すなわち異なるオブジェクトだが内容が同じであることが期待されています。
```c++
struct V
{
    std::vector<char> v;
    V(size_t s) : v(s) {}
};

int main()
{
    V v0(10);
    V v1 = v0;  // コピーコンストラクタが呼ばれる
    v1 = v0;  // コピー代入演算子が呼ばれる
}
```
メンバ変数が全て Copyable である型はデフォルトで Copyable になります。
`std::vector<char>` は Copyable です。
つまり、上記の型 `V` は Copyable です。

以下の `C` のようなクラスが自分で作る典型的な Copyable class です。
```c++
struct C  // Copyable class example
{
    // Default constructor
    C() = default;
    // Copy constructor
    C(const C& rhs) : C() { copy(rhs); }
    // Copy assign operator
    C& operator=(const C& rhs) { copy(rhs); return *this; }
    void copy(const C& rhs) {
        // rhs の中身を *this にコピー
    }
    C(C&&) = delete;
    C& operator=(C&&) = delete;
};
```
`copy()` 関数は、コピー操作の実装です。通常は、メンバ変数を全部をコピーすることが求められます。

Copyable class は以下のように使えます。
```c++
void f(const C& c)
{
    // c を read-only アクセスする
}

void g(C& c)
{
    // c を操作する
}

struct A
{
    C c;
    const C& ref() const { return c; }  // const lvalue reference を返す
    C& ref() { return c; }  // lvalue reference を返す
};

int main()
{
    C c0;
    C c1 = c0;  // copy constructor が呼ばれる
    C c2;
    c2 = c1;  // copy assign operator が呼ばれる
    f(c0);
    g(c1);
    A a;
    const C& c3 = a.ref();  // const 版が呼ばれる
    C& c4 = a.ref();  // non-const 版が呼ばれる
    C c5 = a.ref();  // const 版、copy constructor が呼ばれる
    c5 = a.ref(); // const 版、copy assign operator が呼ばれる
}
```

`A::ref()` はオーバーロードされていてふたつの実体があり、引数や返り値に応じて適切なものが呼ばれます。

ポインタをメンバ変数に持つクラスを Copyable にするのは注意が必要です。
```c++
struct NC
{
    char *p_;
    NC(size_t s) : p_(new char[s]) {}
    ~NC() { delete[] p_; }
    NC(const NC&) = default;
    NC& operator=(const NC&) = default;
};

int main()
{
    NC nc1(10);
    NC nc2 = nc1;  // copy construcor が呼ばれる
} // double free してしまうバグ
```
上の例 `NC` では、敢えて `default` でコピーコンストラクタとコピー代入演算子を明示していますが、何も書かなくても定義されます。
デフォルトのコピー実装は、ポインタを単にコピーしてしまいます。
`p_` を単にコピーすると、2 つの `NC` 型オブジェクトが同一のヒープオブジェクトを指してしまいます。
これは多くの場合、我々がコピーの挙動として期待するものとは異なります。
このようなケースでは、ヒープオブジェクトを別途確保して内容をコピーするコードを自分で実装するか、参照カウンタなどでコピーとして見做せるよう実装するか、明示的にコピーを禁止するべきです。
ヒープオブジェクトを確保するコードを自分で実装してみます。ダメな例では必要があって生ポインタを使いましたが、`std::unique_ptr` を使うべきです。
```c++
struct NC
{
    std::unique_ptr<char[]> p_;
    size_t s_;
    NC(size_t s) : p_(new char[s]), s_(s) {}
    NC(const NC& rhs) : p_(), s_(0) { copy(rhs); }
    NC& operator=(const NC& rhs) { copy(rhs); return *this; }
    void copy(const NC& rhs) {
        if (s_ < rhs.s_) {
            p_.reset(new char[rhs.s_]);
        }
        ::memcpy(p_.get(), rhs.p_.get(), rhs.s_);
        s_ = rhs.s_;
    }
};

int main()
{
    NC nc1(10);
    NC nc2 = nc1;  // copy construcor が呼ばれる
    nc2 = nc1;  // copy assign operator が呼ばれる
}
```
明示的にコピーを禁止するには、`NC(const NC&) = delete;` および  `NC& operator=(const NC&) = delete;` と定義します。


<a name="move-semantics"></a>
### ムーヴセマンティクス

C++11 で、ムーヴセマンティクスが導入されました。
ムーヴセマンティクスの目的は、オブジェクトを安全にムーヴすることです。
ムーヴとは、移譲とか、中身の移動、という操作を指します。
これを所有権の移動と捉えても良いかと思います。
先の `NC` 型は、単純にはコピーできない型でした。しかし、このような型でもムーヴならできます。
```c++
struct NC
{
    std::unique_ptr<char[]> p_;
    NC(size_t s) : p_(new char[s]) {}
};

{
    NC nc1(5);
    // NC nc2 = nc1;  // コピーできない
    NC nc2 = std::move(nc1); // ムーヴはできる
    // nc1 が持っていたデータは nc2 に移譲された
}
```
メンバ変数が全てムーヴ可能な型はデフォルトでムーヴ可能となります。
`std::unique_ptr` はコピーできないがムーヴできる型です。
つまり、この `NC` はムーヴ可能です。
ちなみに、`std:vector<char>` は Copyable かつ Movable なので、`V` はデフォルトでムーヴ可能です。
`std::move` については後で説明します。

ムーヴを使うために、rvalue reference の理解が必要なので、ここで簡単に説明しておきます。
従来の参照型は `T&` という形だけでしたが、C++11 で `T&&` という新たな形が追加されました。
`T&` を lvalue reference、`T&&` を rvalue reference と呼びます。
詳しくは [ここ](https://en.cppreference.com/w/cpp/language/reference) を見てください。
lvalue とか rvalue というのは、expression (式) の分類です。
全ての expression は lvalue, prvalue, xvalue のいずれかひとつに分類されます。
l は left、r は right の略、prvalue は pure rvalue の略、xvalue は expiring value の略です。
lvalue と xvalue をまとめて glvalue、prvalue と xvalue をまとめて rvalue と呼びます。
ものすごく大雑把に分類すると、名前がついてるのが lvalue で名前がついてないのが rvalue です。
例を挙げると、lvalue は変数や、関数などで、アドレスを取れます。
rvalue は即値、関数呼び出し(の返り値)などで、アドレスを取れません。
詳しくは [ここ](https://en.cppreference.com/w/cpp/language/value_category) を見てください。

例外はありますが、大雑把に言うと lvalue reference `T&` は lvalue を受けることができ、
rvalue reference `T&&` は rvalue を受けることができます。
lvalue reference は関数の引数や返り値で使うだけでなく、参照型変数としても使います。
rvalue reference は専ら関数の引数や返り値で使うことが多いです。

何故こんなややこしいルールを導入したのでしょうか。
それは、ムーヴ操作とコピー操作を区別しながらも同様のインターフェースで記述したかったからだと思います。
ムーヴ可能 (Movable) であるときは、ムーヴコンストラクタとムーヴ代入演算子が定義されていて、それらの挙動はムーヴであることが期待されています。
以下のようなクラス  `M` が自分で作る典型的な Movable class です。
```c++
struct M  // Movable class example
{
    // Default constructor
    M() = default;
    // Move constructor
    M(M&& rhs) noexcept : M() { swap(rhs); }
    // Move assign operator
    M& operator=(M&& rhs) noexcept { swap(rhs); return *this; }
    void swap(M& rhs) noexcept {
        // *this と rhs の中身を入れ変える。
    }
    C(const C&) = delete;
    C& operator=(const C&) = delete;
};
```
`swap()` というメンバ関数は、通常全てのメンバ変数の中身を入れ替えるという操作を指します。基本的な型については、`std::swap()` という関数が `#include <utility>` に用意されています。
`move` された後のオブジェクトは不定であり再初期化なしには使ってはいけないこととする設計も可能ですが、「空」の状態とと `swap` するという設計にしておいた方が無難だと私は思います。
`M` では、コピーコンストラクタとコピー代入演算子が `delete` されていますが、これらを実装すれば、Copyable かつ Movable というクラスも作れます。
ムーヴ操作を、コピーと同じ挙動として実装しても意味としてはまず問題はありませんが、一般に、ムーヴ操作は、コピー操作よりも低コスト、高速であることが期待されます。
C++11 以降の STL コンテナは必ずしも Copyable な class でなくても Movable な class であればそれを要素として典型的な使い方が出来るようになっています。

Movable class は Copyable class と出来るだけ同じような使い方ができて、しかしオーバーロードによってコンパイラが挙動を区別できるような仕組みになっています。

```c++
void f(M&& m)
{
    M m1 = std::move(m);  // move constructor が呼ばれる
}

M create()
{
    M m;
    // ...
    return m;
}

struct A
{
    M m;
    const M& ref() const { return m; }  // const lvalue refernece を返す
    M&& ref() { return std::move(m); }  // rvalue reference を返す
    // M& ref() { return std::move(m); }  // M& を返すものと M&& を返すものはオーバーロードできない
}

int main()
{
    M m0;
    // M m1 = m0;  // copy constructor は定義されていないのでコンパイルエラー
    M m1 = std::move(m0);  // move constructor が呼ばれる
    M m2 = create(); // move constructor が呼ばれる
    m2 = std::move(m1);  // move assign operator が呼ばれる
    M&& m3 = std::move(m2);  // rvalue reference で xvalue を受ける
    f(std::move(m3));  // m3 は lvalue なので std::move() で xvalue にする必要がある
    A a0;
    M m4 = a0.ref();  // non-const 版、move constructor が呼ばれる
    M&& m5 = a0.ref();  // non-const 版が呼ばれる
    const M& m6 = a0.ref();  // non-const 版が呼ばれる
    const M& m7 = static_cast<const A&>(a0).ref();  // const 版が呼ばれる
    // M& m8 = a0.ref();  // rvalue は M& では受けられないのでコンパイルエラー
    const A a1;
    // M m7 = a1.ref();  // const 版、copy constructor を呼ぼうとするが、後者がないのでコンパイルエラー
    const M& m8 = a1.ref();  // const 版が呼ばれる
}
```

`std::move()` はただのキャストですが、lvalue を xvalue に変換するという点で意味を持ち、オーバーロードされた別の関数を選択させます。
具体的には lvalue の場合は `const T&` が、 rvalue の場合は `T&&` で受ける実体が選ばれます。
コンパイラが適切なオーバーロード関数を選択するために lvalue と rvalue(xvalue + prvalue) の区別はあると言って良いでしょう。
考えられる全ての組み合わせを挙げたわけではありませんが、我々が Movable class を使う場合は「移動」をしたいのであって、通常はごく一部の組み合わせでしか使いません。

上に挙げた例を見ると、オーバーロードで複数の参照型と const が使われている場合に、不可解な挙動をするようにも見えます。
const でない変数 `a0` において `ref()` を呼び出す場合、`const M&` で受けようとしても `A&&` を返す non-const 版が優先されてしまいます。
const 版を呼ぶには `static_cast<const A&>` を使う必要があります。
この例では敢えてオーバーロードさせてありますが、rvalue reference を返す関数を定義するときは、lvalue reference を返す関数とオーバーロードさせるのはやめて関数名を分けるのが懸命でしょう。

注意点として、ムーヴコンストラクタ、ムーブ代入演算子、`swap()` は noexcept で実装しておくのが良いです。
`std::vector` などはメモリの再確保時に強い例外安全性を保証するために `std::move()` ではなく `std::move_if_noexcept()` を使います。
このとき、コピーコンストラクタと noexcept がついていないムーヴコンストラクタの両方が使える要素型においては、期待と異なりコピーコンストラクタが呼ばれてしまうからです。


<a name="reference-type-selection"></a>
### 参照の使い分け

関数の仮引数を参照型にする場合、`const T&`、`T&`、`T&&` のうちどれで受けるか迷うかも知れません。
そのようなときは以下のように使い分けると良いでしょう:
1. 関数内で対象オブジェクトを変更しない場合は `const T&` で受ける
2. 関数内で対象オブジェクトを変更して、後で呼び出し側がそれを使う場合は `T&` で受ける
3. 関数内で対象オブジェクトをムーヴして、後で呼び出し側がそれを使わない場合は `T&&` で受ける

`const T&&` も存在していますがまず使うことはないでしょう。
一時オブジェクトなどの rvalue は `const T&` または `T&&` で受けられるからです。
`const T&&` は込み入った用途で使うことがあるようですが、それは、どの種類の引数をどの種類の参照が受けられるか、オーバーロードでどのシグネチャが優先されるか、などを熟知した人がとても特殊な用途で使うものでしょうから、我々が気にする必要はありません。


<a name="exception"></a>
## 例外

<a name="exception-introduction"></a>
### 例外の概要

C++ の例外は、大域脱出の手段です。
例外オブジェクトを作成し、`throw` 文で投げます。
`try` 節の中で投げられた例外オブジェクトは呼び出し側を辿ってスタックを巻き戻し、最初に `catch` 節(例外ハンドラ)が定義されているところまで処理を飛ばします。
ただし、`throw` 文を投げる時点で生きていたスタックオブジェクトで、例外ハンドラに到達するまでの間にスコープを抜けて寿命を終えたものを対象としたデストラクタの呼び出しだけは必ず実行されます。
```c++
int main()
{
    try {
        A a;
        // ...
        throw std::runtime_error("error message");
        // ...
    } catch (std::exception& e) {
        ::printf("error %s\n", e.what());
    }  
}
```
この例では `catch` 節の実行前に `a` の寿命が終わってデストラクタが呼ばれます。

スレッドの一番上の呼び出し側コード(メインスレッドの場合は main 関数)に至っても例外ハンドラが定義されていない、すなわちその例外を投げたコードがどの `try` 節にも含まれていなかった場合、プログラムは強制終了します。
マルチスレッドプログラムの場合、ひとつのスレッドで例外をキャッチしそびれるとプロセスまるごと死にます。
STL も例外を飛ばす可能性がありますから、例外は常に飛ぶ可能性があると考えて、コードを書くようにしましょう。
つまり、一番上の呼び出しコード (main 関数やスレッドの起動時に実行する関数) で例外ハンドラを定義するのを忘れないようにしましょう。
STL で投げられる例外や、お行儀の良い大抵の例外型は `std::exception` を継承していますので、それで受ければほぼ全ての例外がキャッチできます。
例外を飛ばさないのは、C 言語互換の関数と、`noexcept` 指定で例外を飛ばさないことが明示されている関数だけで、それ以外は全部飛ばす可能性があるものとして扱いましょう。
ただし、デストラクタは何も指定しなくてもデフォルトで `noexcept` 扱いとなります。

C++ 例外の問題点として、その実現にはコストがかかります。
バイナリサイズが増えるし、遅いです。
その原因は大域脱出の仕組みだったり、途中経路のデストラクタ呼び出しのための処理だったりするようです。


例外がどこで発生したのかを知る方法は標準では用意されていません。
自分で問題を解析するために必要な情報を例外オブジェクトに付加する必要があります。
たとえばデバッグが目的ならスタックトレース情報などが欲しくなるでしょう。
標準ライブラリではありませんが、例えば、[cybozulib](https://github.com/herumi/cybozulib/) の `cybozu::Exception` はコンストラクタでスタックトレースを取ってオブジェクト内に保持し、例外ハンドラでそれを参照できる機能を持っています。


<a name="exception-in-destructor"></a>
### デストラクタ内で発生した例外処理

例外を投げている途中に例外が投げられたらどうなるでしょうか？そのようなことが起こり得るのは、オブジェクトのデストラクタ内の処理です。
例外が投げられても、スコープを抜けたオブジェクトのデストラクタは必ず実行されるのでした。
例外が飛んでいる最中のデストラクタ処理で、デストラクタの外に新たな例外が投げられることが分かったときにプログラムは強制終了されます。
逆に言えば、デストラクタ内で例外が発生しても、例外ハンドラをデストラクタ内に定義しておいて、例外処理すれば、プログラムは続行できます。

このような理由から、デストラクタ実行中に発生した例外の処理はほぼ握り潰さざるを得ませんが、それをどう扱うかはプログラム設計における選択になります。
以下に例を挙げますが、敢えてログを吐くか(`~A()`)、潔くプロセスを自分で殺すか(`~B()`)、無言で握り潰すか(`~C()`)、などの選択肢があります。
握り潰すとは例外をキャッチしておいて何もしないことです。


```c++
~A() {
    try {
        // try to deallocate resources...
    } catch (std::exception& e) {
        try {
            // try to put logs.
        } catch (...) {
            // do nothing
        }
    }
}

~B() {
    try {
        // try to deallocate resources...
    } catch (...) {
        ::exit(1);
    }
}

~C() {
    try {
        // try to deallocate resources...
    } catch (...) {
        // do nothing
    }
}
```

<a name="exception-and-return-value"></a>
### 例外と返り値などの使い分け

例外は便利ですが、重たいというデメリットもあるため、使いどころには注意した方が良いでしょう。
発生頻度が高く、例外処理が性能に影響を及ぼし得るエラーについては、例外を使わずに返り値や参照引数経由でエラー情報を呼び出し側に伝え、条件分岐を用いてエラー処理を行う方が良いでしょう。

C++ でプログラムを書き、STL のコンテナなどを使う時点で、`std::bad_alloc()` が投げられる可能性は常にあります。
C++ で書かれたコードは RAII の影響もあって、至るところで暗黙にメモリアロケートされる傾向にあります。
例外ハンドラも例外ではありません。例外ハンドラ内で `std::bad_alloc()` が投げられたら適切に処理してプログラムを動かし続けることは困難だと思います。
そういう意味では、C++ は C よりもメモリにシビアな環境で動かすのは難しいのかも知れません。
そのような環境を前提に C++ でプログラムを開発する場合は、例外や STL 等を使わないなどの特殊な使い方をする場合があるかも知れませんが、本ドキュメントで対象としている C++ の便利さを享受できなくなるのが辛いところです。


<a name="exception-spec"></a>
### 例外仕様

C++ の関数には、例外の種類を列挙させ、それ以外は投げられないことを示すインターフェースがあり、例外仕様と呼ばれていたそうです。
具体的には `void f() throw(std::runtime_error);` といったものです。
しかし、C++11 で例外仕様は非推奨になり、C++17 では削除されました。
どうやら多くのコンパイラがこれを真面目に実装せず、単に無視するだけだったようです。
代わりに C++11 では `noexcept` キーワードが導入されました。
これは、例外が投げられるのを許可するかしないかだけを指定する、より単純なものです。
`noexcept` を指定した場合は例外が投げられるのを許可せず、実際に投げられたら、呼出側に例外ハンドラが定義されていたとしても、即座にプログラムは強制終了されます。
`noexcept` を指定しない場合は、例外は投げられ得るものと見做されます。
この情報は例外処理の最適化などに使われるようです。

デフォルトのデストラクタが `noexcept` かどうかは[ここ](https://en.cppreference.com/w/cpp/language/destructor)に書いてあるように、条件によって決まるようですが、通常は `noexcept` であると思って良いです。
また、`virtual` にする場合などを除いて、空のデストラクタを自分で定義するのは良くありません。
`std::is_trivially_destructible<T>` が `false` になってしまい、オブジェクト再利用時などの最適化が効かなくなるからです。

C++17 以降 `noexcept` 指定が関数の型情報に含まれるようになったので、関数ポインタを扱うときはその型に注意しましょう。
`noexcept` の有無のみ異なるオーバーロードは許されないようですが、`noexcept` 指定した関数ポインタに `noexcept` でない関数は代入できなくなるようです。


<a name="const"></a>
## const

### const を制するものは C++ を制す

[const や volatile ](https://en.cppreference.com/w/cpp/language/cv) キーワード は cv-qualifiers と呼ばれます。
volatile は一部の特別な用途を除いてほぼ使わないので、ここでは気にしないことにして、const の有り難さについて説明していきます。
const をうまく使うことで、コードの読み易さ、メンテナンスのしやすさは格段に上がると思ってください。
const というのは我々がプログラム内の変数や関数に与える制約であり、const を使えばコンパイラがその制約を満たしているかどうかをチェックしてくれます。
仮に const がなかったとしても C++ で作るプログラムに出来ることは変わりません。
しかし、const を適切に使えば我々は const に大いに助けられていることを実感するでしょう。
C 言語においても const は有り難いものでした。
C++ にはメンバ関数によって振る舞いを自分で定義できるクラスがあり、これが const の仕組みを使うことでさらに強力に我々をサポートしてくれます。


### const の意味

const は constant の略で、不変の、という意味を持ちます。
const を使うことで、変数やオブジェクトに「変えられないよ」という制約を与えることになります。
別の言い方をすると、read-only という性質を持つわけです。
人間というのは忘れっぽい生き物なので、昨日の時点で変えないと決めたものを、今日になると変えようとするコードを平気で書いてしまうものです。
コンパイラが const の記述を見て、コラコラ、それは変えられないよ！と怒ってくれるので、我々は、ああ、そこには変えられないという制約を入れたんだった、と我に返ることができ、間違ったまま開発が進むことを避けられます。
重要なことは、プログラムにおいて、データの変更よりも参照する(参照型変数と混同するのでややこしいですが、ここでは変更を伴わない read-only アクセスのことです)ことの方が多いという事実です。
const によりオブジェクトの変更が発生するコードを限定しておくことで、コードを読むときや変更するときに考えなければならないことがぐっと減ります。


### const 変数

変数の種類は 3 つあるのでした。
値型変数、ポインタ、参照。
これら全ての宣言に const をつけられます。
ひとつづつ説明していきます。


値型変数を const として扱うときは、変数宣言時に型の前に `const` をつけます。
`int` のような算術型であれば `const int i = 1;` のように、代入演算子で初期化し、
クラス型 `A` であれば、`const A a(arg1, arg2, ...);` もしくはその他の手段でコンストラクタを呼んで初期化します。
const 変数 `i` や `a` は変更できません。
変更できないとは、以下の意味を持ちます:
- メンバ変数へのアクセスは non-const のものも含めて全て const 扱いになります。変更できません。
- const メンバ関数は呼べますが、non-const メンバ関数は呼べません。

値型変数への再代入操作は、コピー代入演算子かムーヴ代入演算子が呼ばれたことになります。
算術型などの基本型の再代入は non-const メンバ関数だと見做して良いです。
すなわち const 値型変数への再代入はできません。
変数宣言時の初期化以外の手段で値を設定変更できません。

```c++
struct A
{
    int i;
    A() : i(0) {}
    A(int i0) : i(i0) {}
    void const_func() const {}
    void nonconst_func() {}
};

int main()
{
    const int i = 10;
    // i = 20;  // コピー代入演算子は non-const なので呼べない
    int j = i;  // もちろん読むことはできる

    const A a(10);
    // a.i = 20;  // a は const なので、メンバ変数は const 扱いとなり変更できない
    j = a.i; // もちろん読むことはできる
    a.const_func();
    // a.nonconst_func()  // a は const なので non-const メンバ関数は呼べない
    // a = A(30);  // コピー or ムーヴ代入演算子は non-const なので呼べない
}
```

ポインタの宣言では、const を付ける場所によって 2 通りの意味があります。
`const A* const a;` と書いたとき、ひとつ目の const は、以下の意味を持ちます:
- (ポインタが指すオブジェクトの) メンバ変数へのアクセスは non-const のものも全部 const 扱いになり、変更できません。
- (ポインタが指すオブジェクトの) const メンバ関数は呼べますが、non-const メンバ関数は呼べません。

ふたつ目の const は、以下の意味を持ちます:
- ポインタ変数への再代入はできません。宣言時の初期化以外で値(アドレス)を設定できません。

ふたつ目の const を使うことはあまりありません。
ポインタを使うときは、ポインタが格納しているアドレスを変更するよりも、
ポインタが指しているオブジェクトそのものを変更できるかどうかに注目することが多いからです。

```c++
int main()
{
    A a(10);

    const A* a0 = &a;
    // a0->i = 20;  // a0 が指すオブジェクトの non-const メンバは呼べない
    int j = a0->i;  // 読むことはできる
    a0->const_func();
    // a0->nonconst_func();  // 呼べない
    // *a0 = A(30);  // 呼べない
    a0 = nullptr;  // ポインタの再代入はできる

    A* const a1 = &a;
    a1->i = 20;
    a1->nonconst_func();
    *a0 = A(30);
    // a1 = nullptr;  // ポインタの再代入ができない

    const A* const a2 = &a;
    // a2->i = 20;
    // a2->nonconst_func();
    // *a2 = A(30);
    // a2 = nullptr;
}
```

const 参照変数は `const A& a;` のように書きます。ポインタのようなふたつめの `const` はありません。
`=` 演算子によって const 参照変数に再代入する操作は、それが指すオブジェクトのコピー代入演算子かムーヴ代入演算子を呼んだことになり、
それらの演算子は const ではないので、もちろん許されません。
つまり、const 参照が指すオブジェクトへの再代入は(少なくとも const 参照経由では)出来ません。
参照変数の宣言時からそれが指しているオブジェクトの中身を設定変更できません。

```c++
int main()
{
    A a(10);

    const int& i = a.i;
    // i = 20;  // コピー代入演算子は non-const なので呼べない
    int j = i;  // もちろん読むことはできる

    const A& a0 = a;
    // a.i = 20;  // メンバ変数は const 扱いとなり変更できない
    j = a.i; // もちろん読むことはできる
    a.const_func();
    // a.nonconst_func()  // non-const メンバ関数は呼べない
    // a0 = A(30);  // コピー or ムーヴ代入演算子は non-const なので呼べない
}
```

宣言した変数が const だった場合、周辺コードを修正しようとしたときに、我々はその変数は
「変更されない」ものとして扱って良いわけです。
変更すべきでないと思って const で変数を宣言したけれど、後日、そのことを忘れて誤って変更しようとしたとき、コンパイラが怒ってくれますので間違いに気付きやすいのです。
コードを読む人も、主にオブジェクトがどう変更されるかに注目して処理の流れを追うことが多く、変数が const 宣言してあれば、初期化時以外は注意の対象から外して良いと分かるので、負担が減ります。


<a name="function-parameter-return-value-const"></a>
### 仮引数や返り値の const

関数の仮引数に `const A a` と書くのは好みの問題ですが、どうせ値渡しでコピーされているので、呼び出し元には影響がありませんし、関数シグネチャも値渡しの場合は const のありなしで区別されません。
関数内ではもちろん const 変数として扱われますが、インターフェースとしては違いがありませんので、私は値渡しの場合は const を付けないことにしています。
もしどうしても const にしたかったら、`A a` と仮引数に書いておいて、関数の最初で `const A& a0 = a;` とでも宣言して `a0` を使えばある程度目的は達成されるかも知れませんが、これは面倒くさい割にメリットが少ないかなと私は感じます。

関数の返り値にも `const A` と書けますが、手元でコンパイラを動かしてみたら、warning が出ました。
返り値の場合は、`const A f()` と `A f()` のシグネチャの区別がされないだけでなく、挙動の違いもありません。
つまり値型を返す場合は `const` を付ける意味がまったくありません。


関数の仮引数に `const A* p` と書いたとき、関数内では `p` が指すオブジェクトを変更できないことを意味します。
呼び出し側は関数呼び出し後も `p` が指すオブジェクトが変更されていないことをほぼ確信できます。
これがメンテナンス性にとても影響します。
自分が読んでいる、または修正しているコードにおいて、関数呼び出しがあったとき、ポインタ渡しまたは参照渡しした変数の中身が関数呼び出しの前後で変わるかも知れないと分かれば、それがどう変わるのかを知る必要があります。
実際は中身を変えていないとしても、引数に const がついていなければ、変えていないかどうかコードを読んで確認しないといけません。
const がついていれば、その中身に立ち入ることなく安心して変えられていないことを信じられます。
実は、`const_cast` などで無理矢理キャストすればオブジェクトを変更できますが、そんなことをするコードはお行儀が悪く、忌むべき存在です。
const を適切に使った場合、`A* p` を引数として持っている関数は、 `p` が指すオブジェクトを変更することが想定され(条件分岐の結果変更しないケースはあるでしょうけれど)、`const A* p` を引数として持っている関数は、`p` の指すオブジェクトを変更しないことが分かります。
ポインタ仮引数に関して、const の有無は異なるシグネチャとして区別されますので、`void f(const A* p)` 版と `void f(A* p)` 版は別の実体としてオーバーロード定義できます。


関数の返り値に `const T*` を返すとき(`T*` も同様ではありますが)、少なくとも関数内ローカル変数へのポインタではないことは確認しておいてください。
寿命が尽きているオブジェクトを指しているポインタ/参照を dereference するのは明らかなバグです。
引数もしくはグローバル変数/メンバ変数に含まれるオブジェクト、それらが指しているヒープオブジェクトなどが指されているはずです。
この const は、返った先でそれが指しているオブジェクトが変更されないことを約束します。
`T*` を返してしまったらオブジェクトが変更されても文句はいえません。
変更されたくない場合に const ポインタを返すことはよくあります。
コードの影響範囲という意味において、`const T*` を返すか `T*` を返すかは明らかに後者の方が影響範囲は大きいと見るべきです。
ただ、グローバル関数の返り値がポインタであるとき、const をつける意味は限られます。
引数が const で変更する権限がないから、返り値にも const をつけているときくらいでしょうか。
グローバル変数から辿れるオブジェクトを指している場合は、大体のケースで誰でも変更できますので、関数の返り値が const ポインタである意味があまりありません。
const ポインタを返す方法が多用されるのは、オブジェクトのメンバ関数で、メンバ変数へのポインタを返すときです。
オブジェクト外の人に読まれるのは構わないけれど、変更されるのは拒否したいときに役に立ちます。
関数呼び出し側からは直接アクセスできないファイルローカル変数へのポインタを返す場合は、
グローバル関数の返り値でも const ポインタにする意味があるでしょう。

参照については、仮引数、返り値、共にポインタと同様です。


### const メンバ変数

const メンバ変数とは、クラスのメンバ変数宣言において `const` を指定したものです。
こうすると、コンストラクタの初期化子で初期化した後はオブジェクトの外はおろかメンバ関数内でも一切変更できなくなります。
例えば、immutable objects (不変オブジェクト) を作る方法として、メンバ変数を全部 const で宣言してしまうという方法があります。
こうすると、オブジェクト自身を const 変数として扱わなくてもメンバ変数が全て const なのだから一切変更できません。

```c++
struct A
{
    const int i;
    const int j;
    A(int i0, int j0) : i(i0), j(j0) {}
};

int main()
{
    A a(10, 20);  // const 変数ではないのに変更できない
    // a.i = 30;  // const メンバ変数なので変更できない
    // a.j = 40;
}
```

逆に、デフォルトコンストラクタで何もしないことにして(例えば、`struct A { A() = default; };` ) 、後でメンバ変数を設定しようと思っていたら、メンバ変数は const にできません。

```c++
struct A
{
    int i;
    int j;
}

int main()
{
    A a;
    a.i = 10;
    a.j = 20;
}
```

この 2 つの例は極端なものですが、具体的にどうするかは設計次第だと思います。
私は const 変数がたくさんあるクラスはあまり作りたくありません。
コンストラクタで初期化子をたくさん書きたくはないからです。
そのような場合は const にしたい変数をまとめたクラスを別途作って、そのオブジェクトもしくは参照を
const メンバ変数として持つのが良いかなと思います。
また、少なくとも私は immutable object を作りたいと思ったことはないですが、
絶対に変更したくない、されたくない、という強い意思が伴えば今後作ることがあるかも知れません。


### const メンバ関数

const メンバ関数はとても重要です。
オブジェクトが const であるとき、すなわち `const T` 型であるか、`const T&` または `const T*` で指されているとき、その変数経由では、const メンバ関数しか呼び出しできません。
つまり、クラスを定義するときは const オブジェクトの振る舞いを定義するために const メンバ関数と non-const メンバ関数を分けます。
const メンバ関数内では、non-const メンバ変数であっても const 扱いになり、変更できません。
ですから、const メンバ関数はオブジェクトの状態を何も変更できないことになります。
これは const オブジェクトとして期待される振る舞いですね。

例外として、実際は変更されるけれど、オブジェクトが変更されたと見做したくない場合、
例えば mutex オブジェクトなどについては、`mutable` キーワードをつけてメンバ変数を宣言しておくことで、
const メンバ関数の中で変更が可能になります。
これはあくまで例外的な操作のためのものなので、多用は禁物です。
人から聞いた話ですが、過去に `mutable` を使ったクラスを設計したところ、
後のユーザに const メンバ関数はスレッドセーフだと思われたが、
mutable 変数を操作している const メンバ関数は状態を変更しているので、
実はスレッドセーフではなく、困ったそうです。

const メンバ関数は non-const メンバ関数とオーバーロードできますので、必要に応じて定義してください。
以下のような例が挙げられます。

```c++
struct A
{
    std::string s;
    const char& get(size_t i) const { return s[i]; }
    char& get(size_t i) { return s[i]; }
};
```
const 版では const 参照や const ポインタを返すことによって、const オブジェクトとしての振る舞いを保つことができます。
このようなオーバーロードは STL コンテナでよく使われています。


### const 教のお約束

C/C++  の const (もしくは他言語における同様の機能) を適切に使うことにより、コードの読み書きにおいて多大な恩恵を受けられると信じる宗教のことを const 教というらしいです。
その教義は以下の 2 つだと思います:
1. 変更されないのに、const をつけずに放置してはいけない。
2. const がついているのに、キャストなどを使って無理矢理中身を変更してしまってはいけない。

これらは const の恩恵を受けるための「お約束」です。
お約束を良く考えずに破ってしまうと、const で信頼されている世界が崩壊していまい、メンテナンス性を著しく下げてしまうでしょう。
また、お約束が守られていないコードを書いてしまったら、レビューで怒られる可能性が高いです。

とはいえ、何事にも例外はあります。
ひとつ目の例外は、実際にはオブジェクトの一部を変更するが、コードの意味としてオブジェクトが変更されたとはみなすべきではないとき、
キャストや `mutable` を使って変更することは多少は許容されるでしょう。
ただし、何故そうするかをコメント等で書いておくのが親切です。
コードを読む人に言い訳しておく必要があると思います。
そして、const であることに矛盾が生じない設計を心がける必要があると思います。
ふたつ目の例外は、高々数行のスコープしかない変数について、実質的に const であることがすぐに分かるものでも
const を付けるべきかどうかという問いに対して、私は別に見てすぐに分かるならそこまで気にする必要ないじゃないか、と思います。
迷ったときは可読性やメンテナンス性という目的に合うかどうかを考えれば良いと思います。
より上位の目的はメンテナンス性であり、const に固執しすぎる必要はありません。

const 教を無理に信じなくても、const が適切に使われるコードを読んだりメンテナンスする機会があれば、
その有り難みを実感、納得でき、const をうまく使えるようになるでしょう。
私は信者なのかって？原理主義というわけでもありませんが、初心者向けの本ドキュメントに const のことを力説するくらいには信者だと思います :)


## テンプレート

[C++ テンプレート](https://en.cppreference.com/w/cpp/language/templates)は、コードジェネレータであると同時にコンパイル時計算の手段でもあります。
後者の役割は、テンプレートを使って実現するには不便すぎて一部の物好きのための機能としか思えませんでしたが、その役割は  `consexpr` が担いつつあるようなので、ここでは今後も典型的に使われるであろう前者の役割に注目します。


### 出来ること

テンプレートは、型を引数として受けとって、クラス(型)や関数をコンパイル時に生成するものです。
型を具体的に示さないまま、クラスや関数の内容を記述することによってテンプレートを定義できます。
テンプレートに実際の型を渡して実体化するときに、その型が持っていない機能をテンプレートの内部で使っていたら、
コンパイルできずにエラーになります。


### 使い過ぎに注意

ベンチマークなどで設定パラメータを複数用意して実験することがあります。
それぞれのパラメータ毎に `if` 文で動的に条件分岐するのは性能に影響が出そうだから嫌だな、と思ったことがあって、パラメータを最内ループで分岐させるのではなく、`main` 関数の最初で全部分岐させてしまい、それぞれのパラメータセットに特化したコードを実行するように、全部テンプレート引数として実装してみました。
例えば以下のようなコードです:

```c++
tamplate <int A, int B, int C>
void disaptch3(const Option& opt)
{
    // A, B, C を条件として分岐する。

    // 条件分岐済みのコードが生成される。

}

template <int A, int B>
void dispatch2(const Option& opt)
{
    switch (opt.c) {
    case C1:
        dispatch3<A, B, C1>(opt); break;
    case C2:
        dispatch3<A, B, C2>(opt); break;
    // ...
    }
}

template <int A>
void dispatch1(const Option& opt)
{
    switch (opt.b) {
    case B1:
        dispatch2<A, B1>(opt); break;
    case B2:
        dispatch2<A, B2>(opt); break;
    // ...
    }
}

void dispatch0(const Option& opt)
{
    switch (opt.a) {
    case A1:
        dispatch1<A1>(opt); break;
    case A2:
        dispatch1<A2>(opt); break;
    // ...
    }
}
```

この例だとパラメータは 3 つですが、実際にはパラメータの数は 5 つくらいで、それぞれ 4 個くらいの値が存在していたでしょうか。
・・・どうなったか皆さんもうお分かりですね？  4 の 5 乗個 = 1024 個程の似て異なるコードがテンプレートから生成され、本来なら数秒で済んでいたコンパイル時間が 10 分を越えたあげく、バイナリサイズが巨大になってしまいました。
このように、簡単に書いて組み合わせ爆発をするテンプレートを書けてしまえますが、手に終えません。
このような用途では、Just-in-Time コンパイルの手段を模索するか、CPU の分岐予測を信じて通常の `if` 文を使うしかないでしょう。


### パーフェクトフォワーディング

パーフェクトフォワーディング (完全転送) は、lvalue reference で受ける実装と rvalue reference で受ける実装をオーバーロードしている関数があったとき、それをまとめてテンプレートで扱う仕組みです。
ひとつなら 2 個テンプレート書けばいいじゃないかと思いますが、呼び出しが n 段になると 2 の n 乗個定義しないといけなくなり、実質不可能なので、このような機能が欲しくなるようです。

やり方は簡単です:
1. 型引数にして (ここでは仮に `T` とします)、
2. 自らは `T&&` で受け (const とか付けたらダメです)、
3. `std::forward` で包んでオーバーロードしている関数に渡す

これだけです。
何故このような動作になるかを知りたい人は、他の資料か C++ 仕様を参照ください。
私は知識が足りなくてうまく説明できませんが、このような挙動を実現したい人達が、関数やテンプレートのシグネチャマッチングルールなどをうまく設定したのだと思います。


### テンプレートの限界

C++ のテンプレートをコンパイル時計算(メタプログラミング)のための言語と見做した場合、それは関数型プログラミング言語のような特徴を持っています。
繰り返し処理は再帰を使わないと実現できないだとか、条件分岐もテンプレートの特殊化によるマッチングなどを利用して行われるとか。
元々は、複数型に対して同じ処理をするコードをまとめて記述したい、という素朴な目的で作られたものが、結果として、ほぼチューリング完全の能力を、あくまで私の主観ですが、使いやすいとは言えない状態で獲得してしまったように思います。
C++ のような手続型スタイルで、繰り返し処理や条件分岐をコンパイル時に実行し、コード生成する、という形のメタプログラミング言語だったら、もっと使い勝手の良いものだったんじゃないかと思います。
同じことを思う人は C++ 標準策定に関わる人達にもいるようで、
C++11 で登場した `constexpr` や C++17 で導入された `if constexpr` (これは完全な形でのコンパイル時条件分岐ではないのが悲しいです)などが、
より使いやすいメタプログラミング手段の萌芽に見え、ひそかに期待するところではあります。


### テンプレートを駆使する方へ

ここまで読んでも「俺/僕/私は C++テンプレートを極めるんだ！」という勇敢な方や「C++ テンプレート駆使しないとどうやらやりたいことが出来ないようだ。。。」という気の毒な方は頑張ってください。
私はあまり詳しくないので良い情報を提供できませんが、いくつか日本語でも書籍は出ているようです。
[boost template metaplogramming](https://www.boost.org/doc/libs/?view=category_metaprogramming) にも便利？なライブラリがあります。


## メンテナンス性

本ドキュメントの読者の方々には、是非メンテナンス性を重視してコードを書いてもらいたいと思っています。
必ずしも C++ 特有の話ではないですが、C++ は一歩間違えるとコードや実行結果が大変なことになる気難しい側面がありますので、ここでメンテナンス性についてもう少し具体的に考えてみたいと思います。
メンテナンス性が良いとは、コードの読み手がより少ない労力や時間で必要な情報を得られることと、より少ない労力や時間で必要とするコード修正やテストを行えることだと思います。
つまり、読みやすく、修正しやすいということです。
読みやすさ、修正しやすさを定量的に表すのは難しそうですが、
長い期間使われるコードであればあるほど、コードやドキュメントのメンテナンス性の良さはソフトウェアのコスト対効果の向上に大きな貢献をします。
コードを書くとき、レビューするときは、以下の複数の観点から、よりメンテナンス性の良いコードにするにはどうしたら良いかということを考えてください。


### 部品化

同じ処理が複数の箇所に存在しているとメンテナンス性に悪影響を与えます。
**DRY** (*Don't Repeat Yourself*) 原則と呼ばれますが、コードだけでなくドキュメントやコメントも含めて情報の重複を避けることが求められています。
ある箇所を修正したら、同じ情報が書いてある別の箇所も修正する必要がある場合、DRY 原則に違反しているといえます。
部品化しましょう。
部品化とは、複数の変数や引数をひとつのクラスにまとめたり、複数行のコードを関数として独立させたりすることです。
コード量が単純に減ることで、潜在的にはコードを読む労力が減りますし、重複がないということは、修正の労力も減りますし、修正し忘れを防止できます。


制御構造がコードに埋もれるとメンテナンス性に悪影響を与えます。
`if` や `for` などの制御ブロック内に、大量のコードがあったり、その場での入れ子構造が何重にもなっている状態は、制御構造を把握しづらくさせます。
コードを読む場合、制御構造は今どこを読むべきかを判断するための重要な情報なので、埋もれると読みづらくなります。
また、制御構造を変更・修正する場合、制御ブロック内に大量のコードがあると、これらの一部または全部を移動するテキスト編集が必要となり、その際にミスが起きやすくなります。
このような処理は、たとえ 1 回しか呼ばれないとしても、部品化を検討しましょう。


たった 1 行の処理も部品化すべきでしょうか？ 場合によっては「すべき」といえます。
例えば、何をやっているか一見分からない処理が 1 行で書かれていて、そのような処理が複数箇所で行われていて、その処理を良い名前で表現できるときなどです。
1 箇所でしか使わないなら、コメントにその名前を書いておくのでも良いでしょう。
インライン展開されれば関数呼び出しのオーバーヘッドはありませんので、余程大量に呼ばれる処理でなければ気にせず関数として切り出し、気になるのであれば明示的なインライン化をコンパイラにお願いしましょう。


度重なる修正でクラスのメンバ変数が増えすぎたとき、関数内で定義されるローカル変数が増えすぎたとき、ひとつの関数に渡す引数が多すぎるときも、部品化を検討しましょう。
複数のメンバ変数をまとめて別のクラスに分離したり、複数のローカル変数や引数をまとめてクラスとして定義したり、関数内の一部の処理を別の関数として分離したり、です。
具体的にどのくらいの数や量なら多すぎるのかについては言いづらいですが、
あなたがコードレビューする立場であれば、多いな、と思ったら迷わずそれを指摘し、
部品化するメリットやデメリットについて議論するようにしましょう。


###  疎結合

関数やクラスなどの部品同士が疎結合になっているかどうかも、メンテナンス性に影響します。
例えば、あるクラスだけを見たとき、公開しているメンバ変数や関数インターフェースが少なく、それを呼ぶ箇所が少なくできるならその方がより疎結合だといえるでしょう。
同様に、関数の引数が少ない方が疎結合でしょう。
より疎結合であれば、ある処理を追うときに読まなければならないコード量が減ります。


疎結合であることを、より具体的に表現するとしたら、グラフ構造を使うのが適切かと思います。
モデル化の方法はいくつか考えられますが、例えば関数やクラスがノードで、それらを引数で渡したり関数内で呼んだりするのがノード間のエッジに相当すると考えてみましょう。
グラフ構造が疎結合であるとは、ノードあたりのエッジ本数が少ないこと、を意味します。
異なる機能を実現するコード同士で比較できるものかは分かりませんが、少なくとも同じ機能を実現するためのコード同士、リファクタリング前と後を比較するときに、このようなグラフ構造を考えて、エッジ本数が少ない方がよりメンテナンスしやすいコードであるとは言えると思います。
ソフトウェア工学の分野では、このような構造か、別の構造を用いた、より良い指標があるかも知れませんので、興味のある方は調べてみましょう。


部品化を行うと、上で考えたグラフ構造の上では、ノード数が増え、エッジ数も増えると思います。
大きな関数やクラスを部品とみれば、それらの依存関係は疎結合だったとしても、より細かい単位での部品をノードだと考えれば、依存関係がクラス内や関数内に存在し、それらが実際は密結合であるにも関わらず、その事実が隠れてしまっているだけだったりします。
通常は、部品化を優先させ、それが十分満たされると判断してから、クラスや関数単位での疎結合化を考えるのが良いと思います。


### 名前

変数、関数、クラスの名前はメンテナンス性にとって重要です。
「名は体を表す」の諺通り、中身を読まなくてもその挙動を推測するのに役立ちます。
無意味な名前や、とんちんかんな名前がついていると、読み手は中身を読んでその意味を理解する必要があったり、
誤解して正しい理解を妨げてしまったりします。
良い名前をつけましょう。
品詞の使い分けについては様々な場所で言及されていますので、ここでは議論しません。
ラムダ関数が無名で許されるのは、ひと目見れば内容が分かるくらい単純なもので、わざわざ名前をつけなくても内容の把握が簡単だからなのです。


### const

const を適切に使うことがメンテナンス性に大きな貢献をすることは既に説明しました。
疎結合についてグラフ構造を使って説明しましたが、non-const と const のアクセスでエッジの重みを変えることとし、
non-const よりも const の方が重みが小さくすることとすれば、エッジ重みの総量が小さい方がよりメンテナンス性が良いことを
表現できるかと思います。


### 型

C++ は静的型付け言語に分類されます。
ほとんどの変数やオブジェクトの型が静的に、すなわちコンパイル時に解決されます。
そのルールを逸脱するコードはコンパイルエラーとなります。
Python などの動的型付け言語に比べれば、プログラムを動かす前に型による制約を守っていることが求められるので、わずらわしいと思う人がいるかも知れません。
しかし、メンテナンスの観点からは、静的型付け言語はとても重要な性質を持っています。
それは、コンパイルが通った時点で型エラーは排除されているいうことです。
すなわち、実行しているときに、ある変数と実際のオブジェクトの型が異なって、やろうとしている操作が出来ないという問題は起きないということです。
動的型付け言語では、型エラーの可能性を、テストを充実させることで排除するアプローチを取ります。
ただ、テスト漏れの可能性が常にあることを考えれば、静的片付け言語に比べて非力であることは否めません。
特に長期間のメンテナンスを考えた場合、静的型付け言語が有利だと思います。

例外的な機能もあります。
ひとつは virtual メンバ関数を使って多態しているオブジェクトを格納するポインタに対する `dynamic_cast` です。
これに関しては静的に型が決定せず、動的に型が解決されるため、プログラムのロジックが間違っていれば、`dynamic_cast` に失敗し、セグメンテーションフォールトをするなど不正な動作となります。
もうひとつは、`reinterpret_cast` や C 言語のキャストなどの強制的なキャストです。
強制的なキャストは、コードを書いた人の責任で「無理矢理」そのオブジェクトを別の型であると見なす行為ですから、
その対象が互換性があることを保証する責任はコンパイラではなくコードを書いた人が負います。
もちろん不具合があれば期待通りに動かなかったり、不正な挙動をしてデータが壊れたりします。
キャストは型エラーの可能性を生み出す行為なので、
コンパイラが守ってくれる世界から逸脱する行為であることに十分注意してください。


### コメント

コメントは読み手の理解を助けます。
コードを読めば分かることは書かないようにしましょう。
主に何故そうしたのか、コードを読んだだけでは分かりにくいと思われるときに書きます。
複数のやり方があり得たがなぜそれを選んだのか、そのコードの実行結果は何をもたらすのか、生成物は何に使われるのか、などです。
What ではなく Why を書くようにしましょうと良く言われます。
また、変数や関数の名前が長すぎるのも問題なので、名前は短めにしておいて、意味を補う目的でもコメントを使います。


### テスト

メンテナンス性の担保にテストは欠かせません。
特に、定期的に、もしくはコードの修正が反映された契機にテストを実行してくれる CI (Continuous Integration) ツールの利用は、
我々が安心してコードを修正するのに必須といっても過言ではないです。
コード修正によるリグレッションは長期間メンテナンスするコードでは特に気をつけなければなりません。
リグレッションとは、コードの修正が、かえって不具合を埋めこんでしまうことを指します。
少なくとも、テストを書いてそれを CI ツールで動かすようにしていれば、テストが通らないことでリグレッションの発生をすぐに検知でき、
修正するなどの対応ができます。
テストがカバーしていない領域で発生する不具合は防げませんが、典型的なユースケースは大抵テストがカバーしていますので、
うっかりミスにすぐ気付けるだけでも有り難いものです。

様々なテストフレームワークがありますが、何を使うとしても CI ツールでリグレッションテストを実行することを意識しておけば良いと思います。
ごくごく単純なユニットテスト用途で十分なものとして、[cybozulib](https://github.com/herumi/cybozulib) の `test.hpp` をオススメしておきます。


```c++
#include "cybozu/test.hpp"

CYBOZU_TEST_AUTO(test_a)
{
    int i = 0; j = 0;
    CYBOZU_TEST_EQUAL(i, j);
    CYBOZU_TEST_ASSERT(i != 0);
}
```
このように書いてコンパイルすると、テスト成功時は 0 、失敗時はそれ以外が返る実行ファイルが出来ます。

環境の整備や初期化などが必要なテストは、もっと複雑な機構が欲しくなるかも知れませんが、必要に応じてスクリプトを作ったりして対応すれば良いと思います。
実行したらテスト成功か失敗かが判別できる出力をし、自動化しやすい形でプログラムとして作っておくのが重要です。


## その他

ここでは、書いてみたものの分量が多くなかった雑多な話題について、まとめておきます。


### 入力のチェック

プログラム外部からの入力は、必ず動的に(実行時に)チェックしましょう。
これがセキュリティの脆弱性を生まないための大原則です。
入力データをチェックなしに実行することは危険です。
入力が何らかの形で実行される恐れがある場合は、文字列エスケープなどの処理で危険な操作をされないようにする必要があります。
また、入力データのサイズにも注意しましょう。
必ず現実的な上限を設定しておき、それに従ってチェックすることが肝心です。
バッファオーバーフローという古から使われる有名な攻撃手法は、まさに想定外の長い入力を与え、それをプログラムが受けいれてしまうことによって引き起こされます。


とはいえ、無闇に入力をチェックすると、チェックを無駄に複数回実施することになり、性能が低下してしまいますので、
プログラムの内外の境界について意識して、外から内に入ってくるデータについてチェックするようにしましょう。
また、`assert` はデバッグやテスト用途で便利ですが、通常リリースビルドでは有効化されないものです。
ですから、セキュリティのための入力チェックを目的として `assert` を使わないようにしましょう。


### コンパイラ特有の話

いくつかあるので列挙しながら説明します。


- GCC や Clang のコンパイラオプションには、 `-Wall -Wextra` を必ず付けて多くの warning を出してもらいましょう。
そして、warning が出なくなるまでコードを修正しましょう。
Warning が出るということはリスクのあるコードであることを意味しますし、たくさん warning が出る状態を放置すると、コード修正のときに邪魔になりますし、問題が埋もれて見過される原因になりますので、やめましょう。

- `-pedantic` は ISO C/C++ に準拠しない文法や記法は禁止するというコンパイラオプションです。
場合によっては使いましょう。
いわゆる GCC 拡張が使えなくなります。

- C++ 標準の話と、コンパイラが受けいれる記法や生成するコードの話と、CPU 内部でどう実行されるかの話は、
繋がってはいますが厳密には違うレベルの話なので、区別して考えましょう。
例えば、メモリオーダーの話などがそれに当たります。

- Linux や Windows などの環境の違いによる long や unsigned long のサイズの違いには気をつけましょう。
64bit Linux では、long は 64bit ですが、64bit Windows では 32bit です。
64bit Windows の上で動く環境でも、64bit Cygwin では 64bit だったり、64bit MinGW では 32bit だったり、WSL (Windows Subsystem for Linux) ではやっぱり 64bit だったりします。
これらの基本型のサイズのバリエーションは、LLP64、LP64、ILP64 などと呼んで区別するようです。
Windows や MinGW は LLP64、Linux、Cygwin, WSL は LP64 です。

- ヘッダファイルは同じ内容が複数回読まれないようにファイル先頭に `#ifndef HEADER_NAME` `#define HEADER_NAME`と ファイル末尾に`#endif` を書くことで、一度しか読まれないことを保証する方法が昔は一般的でした。
しかしこの方法は名前 (`HEADER_NAME`) の衝突や、`#ifndef` と `#endif` の対応がおかしくなり得るなどの面倒くささを抱えています。
 昨今は、多くのコンパイラが `#pragma once` という記法をサポートしていて、ヘッダファイルの先頭にこれを 1 行書くだけで、一度しか読まれないことが保証されるようになりましたので、是非こちらを使ってください。

- マクロは、C 言語の時代から使えるものでしたが、プリプロセッサで処理され、ソースコード文法の解釈なしで文字列置換を基本とした処理がなされる仕組みなので、危険がいっぱいです。
定数の定義にマクロを使う伝統もありましたが、C++ では適切な名前空間に const 変数を定義して使うようにしましょう。
コードジェネレータとして使う場合は、テンプレートで代用できないかを検討しましょう。
どうしても使わなければならない場面もあるとは思いますが、出来るだけ少なく留めるのが良いと思います。
また、マクロはヘッダライブラリなども含めて名前空間がひとつしかないので、自分がマクロを定義するときは、多少長くなるのは仕方ないものとして、適切なプレフィックスやサフィックスを付けて名前が衝突しづらくなるようにしましょう。

- `inline` 指定では必ずしもインライン展開してくれるわけではないので、必ずインライン展開したい関数は、コンパイラに強制する必要があります。
GCC や Clang だと `__attribute__((always_inline))` を使います。

- GCC や Clang でソースファイルをコンパイルするときに `-MMD` `-MP` の両方のオプションを指定しておくと、`make` コマンドが解釈できる依存関係ファイルを `.d` 拡張子のファイルとして出力してくれます。
その一方で Makefile に以下のように書いておけばよろしく依存関係を解釈してくれます:
```makefile
  ALL_SRC=$(wildcard *.cpp)
  DEPEND_FILE=$(ALL_SRC:.cpp=.d)
  -include $(DEPEND_FILE)
```

### ヘッダとソース

ヘッダファイルは `.hpp` や `.h` などの拡張子を持ち、原則プロトタイプ宣言だけが書かれていて、
ソースファイルは `.cpp` や `.cc` などの拡張子を持ち、関数やメンバ関数の内容が書いてあるものです。
注意点として、テンプレートは、ファイルローカルでしか使われないものを除いてヘッダファイルに内容を記述しないといけません。
また、インライン展開したい実装は、やはりファイルローカルでしか使われないものを除いてヘッダファイルに書く必要があります。
ソースファイルに書いた実装は、LTO (Link-Time Optimization) の最適化を除いて必ず通常の関数呼び出しとなります。
`main()` 以外の実装をヘッダファイルに書くというスタイルもあり得ますが、複数の実行ファイルを生成する前提で、
コード量が増えてくると、同じヘッダファイルに含まれる同じコードを複数回コンパイルすることになり、コンパイル時間が長くなってきてしまいます。
インライン展開が必要なコードはプログラムの中でごくごく一部でしょうから、あとのコードは大人しくソースファイルに書きましょう。

ヘッダファイルは、歴史的経緯からこのような仕組みとなっているもので、ヘッダの取り込み順序で挙動が変わってしまったり、
複数回の取り込みによるコンパイル時間の増大などの問題があります。
より現代的で便利なモジュールの仕組みを導入しようとする動きが C++ 標準の方であるようです。
対象の公開範囲を調節するだとか、名前を適切に変えて取り込むだとかのメンテナンス性に直結する機能ですので、是非実現して欲しいですね。


### ラムダ式

C++11 で搭載されたラムダ式は、ちょっとした即席の関数オブジェクトを作って関数に渡したいときに便利だと思います。
ただ、やはり使いすぎは禁物です。
というのは、ラムダ式の参照キャプチャを使うと、実質的にラムダ式の外側のスコープにアクセスできるからです。


```c++
void func()
{
    int i = 0;
    // ...
    auto predicate = [&i]() {
        i = 1;
    };

    predicate();
    // i == 1
}
```

この例くらいならかわいいものですが、ラムダ式が巨大化して、参照する変数も増えると、コードの見通しはかなり悪くなってしまいます。
そうなる前に、一部をきちんと名前のある通常の関数として切り出すなどのリファクタリングを行うことをオススメします。

C++14 で追加されたジェネリックラムダ、C++17 で追加された `constexpr` ラムダなど、ラムダ式も機能が増えていますが、
やはり実際にどんな挙動をするかを分かった上で、可読性についても十分考慮して使ってください。
曖昧な理解のままで使うくらいなら使わない方がずっとマシです。


### auto や decltype

C++11 で使えるようになって、その後 C++14 や C++17 で改善され続けている [auto](https://en.cppreference.com/w/cpp/language/auto)や [decltype](https://en.cppreference.com/w/cpp/language/decltype) は、利用範囲が増えてきました。
テンプレートを定義する場合は、これらを使わないと実装が難しいものもあるようですが、通常の関数内で、気軽に使うのはよく考えてからにしましょう。
コードの可読性という視点では、明らかに分かるもの以外で `auto` や `decltype` を使うのはオススメできません。
例えば、[range-based for loop](https://en.cppreference.com/w/cpp/language/range-for)  の要素を受ける変数宣言や、イテレータを返す関数を受ける変数宣言などは、人間が見ても型が推論しやすいでしょうから、`auto` などを使っても読み易さが落ちづらく、
かつ長ったるい型名の記述が減って書く側も読む側もうれしいことでしょう。
それからラムダ式に名前を付けるときは `auto` を使うのが典型的な使い方です。
私はこの 3 つのケースについてはあまり気にせずに `auto` を使っています。
繰り返しますが、型推論してくれるからといって安易に `auto` や `decltype` を使うのはやめましょう。


### コンテナとイテレータ

どのコンテナをどのように使うべきかについては、多くの資料がありますから参考にしてください。
ある型のオブジェクトからなる集合を管理するコンテナとして `std::vector`、 `std::list`、 `std::deque` などがありますが、性能特性が違うので、アクセスの方法によって使いわけられるべきもの達です。
また、`std::map` と `std::unordered_map` は key-value 型のデータを格納するためのものです。
木構造か、ハッシュテーブルかで実装が分かれ、性能特性や能力も違います。
コンテナのメンバ関数は、C++ 標準で計算量などの制約が付けられていたりします。
例えば、`size()` メンバは必ず計算量 `O(1)` で実行できることなどです。
標準で性能基準が定められているものは、実装も制約を受けていますので、コンパイラやそのバージョンによらず、性能特性が担保されることが期待できます。


イテレータについて重要なこととして、範囲を考えるときに
`begin()` は閉じていて(範囲に含まれる) `end()` は開いている(範囲に含まれない)ことを覚えておいてください。
begin が 0 で end が 10 の範囲は、0, 1, 2, 3, 4, 5, 6, 7, 8, 9 という列です。
イテレータに限らず範囲という概念を考えるときはこのルールを守るのが良い戦略だと思います。
その理由は、範囲の分割や隣合う範囲の集約操作が簡単だからだったり、
`0` 始まりの for 文において終点と実行回数が一致するという分かりやすさもあるかと思います。
一番基本的な `for` 文は、以下のように書くことが多いと思います:
```c++
{
    // size_t n;
    std::vector<int> v(n);
    for (size_t i = 0; i < n; i++) {
        // v[i] にアクセス
    }
}
```
これは、`0`, `1`, ..., `n-1` までの `n` 回実行される for loop です。
逆順のアクセスは、
```c++
{
    std::vector<int> v(n);
    for (size_t i = n; i > 0; i--) {
        // v[i - 1] にアクセス
    }
}
```
このように書くと分かりやすいと思います。
これに慣れれば、始点と終点の扱いを気にする頻度が減り、
典型的な操作においてはバグったコードを書けなくなると思いますので、
begin は閉じていて、end は開いているパターンを使うように心掛けましょう。


### boost ライブラリ

[boost ライブラリ](https://www.boost.org/)は C++ の標準ライブラリではありませんが、一部の機能が C++ 標準に取り込まれた実績が多くあるライブラリです。
つまり、boost に入っている機能は次世代の C++ 標準に取り込まれる可能性があります。


自分の使いたい道具が C++ 標準になくて、boost にあったなら、使いたくなるのは当たり前です。
しかし、ちょっと待ってください。
あなたの書こうとしているプログラムは何年使われるものですか？何年メンテナンスする必要のあるものですか？boost は先進的なライブラリなので、古いバージョンは新しいコンパイラでビルドできなくなるかも知れませんし、新しいバージョンの boost ライブラリは API が変わっているかも知れません。
OS のパッケージシステムなどで提供される boost はバージョンがひとつしか選べないか、選べても少ないでしょうし、新しいバージョンの OS には新しい boost が入っています。
あなたのプログラムのメンテナンスのことを考えて、boost を使うかどうかを決めると良いでしょう。
boost のヘッダライブラリだけを使う分には、相対的には互換性問題が発生するリスクが少ないと思います。



## おわりに

⾊々と書きましたが、本当に C++ 初⼼者がこれを読んで初⼼者脱出できるのか。。。という不安もあります。
まだまだ叩かれ磨かれるべき内容だと思いますので、是⾮フィードバックを著者までお願いします。
郷に⼊っては郷に従えの部分もあるでしょうけれど、どのような⾔語を使う場合でも、
プログラムの設計における⼤事なことはあまり変わらないと思いますし、
それを C++ においてはどのように実現するか、ということを重視して書いてきたつもりです。
本ドキュメントによって、C++ でメンテナンスしやすく、安全で、速いコードを書く⼈が増え、
C++ ⼈⼝が増え、C++ が栄えて私が C++ を便利に使える時代が続いてくれたらうれしいな、と思います。
Rust や Go に浮気するかも知れませんがね ;)
それではみなさんも、楽しい C++ プログラミング人生を！！！


## 謝辞

同僚の光成滋生さんには、本ドキュメントの内容について、多くのフィードバックを頂きました。
この場を借りて御礼申し上げます。
また、本ドキュメントをここまで読んでくださった方、ありがとうございます。
また、これから読んでくださる方、フィードバックを下さる方にも、予め感謝を申し上げておきます。


## 更新履歴

- 2018-10-03 v0.6 光成さんからフィードバックをもらって修正
- 2018-08-18 v0.5 メンテナンスについて追加、諸々修正
- 2018-08-13 v0.4 表現の見直し、細かい間違いの修正
- 2018-08-10 v0.3  継承回り修正、追記
- 2018-08-07 v0.2  色々と追加、改善
- 2018-07-30 v0.1 最初のバージョン

