# C++ 初心者からの脱出

サイボウズ・ラボ 星野 喬

<a name="introduction"></a>

## はじめに

本ドキュメントは、C はある程度使ったことがあり、C++ を独学で学び始めた人が、やるべきではないことをいとも簡単にやってしまう状況を少し改善したいと思って書きました。コンパイルは通るけれど、明らかにバグっている、メンテナンス性が悪い、性能面で問題があるコードを書かずに済むようになって欲しいという気持ちが込められています。

C++ は歴史が長いからなのか、とにかく仕様が複雑で大量にあります。仕様を全部理解しないと C++ を使ってはいけないなんてことはありません。脳味噌の容量は有限なのです。一部の C++ を牽引発展させていく人達はそういうわけにもいかないでしょうが、単に良いプログラムを書きたくて C++ を使おうとする我々にとっては、出来るだけ少ない知識で、必要十分に便利な機能を使いこなすのが理想です。逆に、仕様で許されているからといって、やって良い、やるべき、とはならないことが多いのが初心者にとって辛いところだと思います。

本ドキュメントは C++ をまったく書いたことがない人向けではありませんので、網羅性についてはあまり重視していませんし、キーワードをいちいち説明していないこともありますので、適宜ご自分で調べてください。本ドキュメントでは、何故そう書くか、何故そうすべきなのかについて、特に私が強く思っていることを書きます。もちろん、全ての C++ プログラマが同意するような完璧なものではないと思いますが、私の C++ コードを書いたりレビューしたりのつたない経験から得たひとつの解釈ではありますので、参考にしてもらえれば幸いです。

以下の項目の一部または全部に「はい」と答えてしまう人は、本ドキュメントを読むべきだと思います:

- 動的メモリ確保といえば、`malloc` か `new` を使ってやるものだ。
- RAII という言葉を聞いたことがない、聞いたことあるけどよく分からない。
- 変数のスコープや寿命、所有や借用を意識してコードを書いていない。
- ポインタと参照の違いが良く分からない。
- `T&` と `T&&` の違いが良く分からない。
- const を使ったことがない、あまり使わない、その良さが良く分からない。

本ドキュメントでは、主に C++11 でサポートされる機能を対象にします。場合によっては C++14、 C++17、C++20 について言及します。サンプルコードは、比較的最近の GCC もしくは Clang でコンパイルできることを確認していますが、include 宣言などを省略したりしているので適宜追加してください。

まず前提として、C 言語はある程度使ったことがある人を対象にしていますので、[C FAQ](http://www.kouno.jp/home/c_faq/c_faq.html) を眺めて復習してきてください。C++ のオンラインマニュアルとしてオススメなのは、[cppreference](https://en.cppreference.com/) です。日本語であれば [cpprefjp](https://cpprefjp.github.io/) を挙げておきます。サンプルコードを書いて実行してみたり、コンパイラによって出力されるアセンブラコードやバイナリコードを見てみることをオススメします。さらに詳しい挙動を知りたい場合は、C++ 標準のドキュメント([ここ](https://en.cppreference.com/w/cpp/links)にリンクがまとまっています)や、コンパイラのドキュメント([GCC](https://gcc.gnu.org/onlinedocs/)、[Clang](https://clang.llvm.org/docs/UsersManual.html))が参考になるでしょう。C++ と直接関係はありませんが、実際の挙動については CPU のインストラクションや、OS のシステムコールなどについて調べる必要があるかも知れません。

<a name="table-of-contents"></a>
## 目次

[TOC]


<a name="struct-and-class"></a>
## C++ クラスと C 構造体の違い

C++ クラスは C 構造体の概念を内包しています。[POD](https://en.cppreference.com/w/cpp/named_req/PODType) (Plain Old Data) class は C 構造体として C 関数に渡せる、`memcpy` でコピーできるなどの特徴を持ちます。C++11 では、POD の定義が [standard-layout](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType) class と [trivial](https://en.cppreference.com/w/cpp/named_req/TrivialType) class というふたつの概念で表現されるようになり、C++20 では POD よりも後者の概念が主体的に扱われるようになります。Standard-layout class は C 構造体として C 関数に渡せることを、trivial class は `memcpy` でコピーできることを念頭に定義がされています。C 言語で使っていた `struct` の機能以上のものを使っておらず、メンバ変数もそうであるクラスは、間違いなく standard-layout かつ trivial なので安心してください。逆にいえば、C 構造体として C 関数に渡してはいけなかったり、`memcpy` してはいけないクラスが存在するということです。そのようなクラスのインスタンスオブジェクトは、コンパイラが特殊なデータを付加するなどしていますので、注意しましょう。

<a name="cstr-dstr"></a>
### コンストラクタとデストラクタ

C++ クラスはコンストラクタとデストラクタを持ちます。コンストラクタはオブジェクトの初期化時に実行されるコードで、デストラクタは開放時に実行されるコードです。これらは返り値を持ちません。コンストラクタはシグネチャ(簡単に言うと仮引数の数や型)が異なれば複数定義できますが、デストラクタは引数を持たないものひとつだけです。特殊なコンストラクタとして、デフォルトコンストラクタ (`T()`)、コピーコンストラクタ(`T(const T&)`)、ムーヴコンストラクタ(`T(T&&)`) があります。

<a name="member-function"></a>
### メンバ関数

クラスにはメンバ関数を定義できます。メンバ関数は、そのクラスインスタンス特有の処理を行うときに便利です。また、メンバ関数の名前が、同じクラス内のメンバ関数以外からは見えないというメリットや、C 構造体の要素に相当するメンバ変数、とりわけ非公開のメンバ変数に直接アクセスできるメリットがあります。これはメンバ関数やメンバ変数のスコープがクラススコープであるからです。メンバ関数の引数にはクラス外部のもののみ渡せばよいので、シグネチャがスッキリし、分かりやすくなります。

ある処理をグローバル関数とメンバ関数のどちらにすべきか悩んだ場合は、それらのメリットデリットを天秤にかけて決めてください。非公開メンバ変数にアクセスする必要がないのにメンバ関数にする必要はあまりないと思いますが、迷った時は使いやすい方、メンテナンスしやすい方を選ぶのが良いでしょう。s

### オーバーロード

[オーバーロード](https://en.cppreference.com/w/cpp/language/overload_resolution)とは、同じ名前の関数でも仮引数の数や型が異なれば別の関数として扱うことのできる仕組みです。コンストラクタを複数定義したときもオーバーロードしています。何が区別され、何が区別されないかについて、厳密な条件はかなり複雑です。簡単に確認する方法は、実際に複数の同じ名前の関数やテンプレートを定義してみて、コンパイルエラーになるかどうかを見ることです。また、ある引数リストを与えたときに、どのシグネチャが選ばれるのかも、試してみるのが一番早いと思います。避けられない場合を除き、オーバーロード関数をたくさん定義するのは良いこととはいえません。どのシグネチャが選ばれるか分かりづらいと可読性やメンテナンス性が落ちるのはいうまでもありません。複雑なものは分かりにくいのです。同じ名前にする意味があるのかどうかを自問自答してください。別名でも問題ないのなら別名にしてください。迷ったら別名にすべきです。

オーバーロードを使う典型的な例をいくつか挙げておきます:

1. コンストラクタ
2. メンバ関数の const 版と non-const 版
3. const lvalue 参照を受けとるコピー版と、rvalue 参照を受けとるムーヴ版
4. 異なる型を扱うが同じ操作を意味する関数、演算子

最後の例は、テンプレート関数を定義することで、オーバーロードされた複数の関数をまとめて自動生成することも多いと思います。

<a name="operator-overload"></a>
### 演算子オーバーロード

演算子オーバーロードとは、演算子の実装を自由に定義できる機能です。演算子といってもたくさんあるので、用途に応じて独自の定義をする演算子は限られるでしょう。ここではクラス `T` のメンバ関数として定義する演算子の代表的なものを挙げておきます。

####  比較演算子

`bool operator==(const T&) const`

`bool operator!=(const T&) const`

`bool operator<(const T&) const`

`bool opeator>(const T&) const`

`bool opeator<=(const T&) const`

`bool operator>=(const T&) const`

- オブジェクトの一致性や順序性を表すのに使えます。
- 最近のコンテナやアルゴリズムは、比較のための関数オブジェクトを受けつけることが多いので、必ずしもクラスの側に比較演算子を実装する必要はないことが多いです。
- 一致性を意味する `==` と `!=` は、同時に定義し、一貫性が損われないようにしましょう。例えば、必ず `bool operator!=(const T& rhs) const { !operator==(rhs); }` としておくなど。
- 順序性 `<` `<=` `>` `>=` についても同様です。
- 比較演算子を含む一部の演算子は、グローバル関数としても定義できます。例えば `bool operator==(const T& lhs, const T& rhs)` と、クラス `T` 内で定義する `bool operator==(const T& rhs)` は同じシグネチャとして扱われ、同時には定義できません。

#### 代入演算子

`T& operator=(const T&)`

`T& operator=(T&&)`

- オブジェクトのコピーやムーヴを実装したいときに定義します。
- コピーコンストラクタやムーヴコンストラクタと一緒に定義されることが多いです。コピーのみ、ムーヴのみサポートするクラスもありますし、両方サポートするクラスもあります。

#### ファンクタ

`... operator()(...)`

- 関数オブジェクトとして振る舞うときの挙動を定義できます。引数や返り値の型は自由に決められます。例えば `int` と `float` を受けとり、 `int` 型を返すファンクタは `int operator()(int, float)` と書きます。 
- 関数オブジェクトとして振る舞うことを求められているとき以外は、きちんと名前を付けて通常のメンバ関数として呼ぶべきです。名前を付けるのが面倒くさいという理由でファンクタにしてはいけません。可読性が落ちます。

####  添字演算子

`T& operator[](size_t)`

`const T& operator[](size_t) const`

- 要素へのアクセスを実現するために定義します。`std::vector` や `std::string` が持っていますね。

#### その他

たくさんあるので必要に応じて自分で調べてください。

オーバーロードなので、引数の異なる型ごとに演算子を定義すればもちろん挙動を変えることができます。ただし、実体が選ばれる条件が複雑になってしまい、間違えやすくなるようならオーバーロードは諦め、異なる名前をつけたり、異なるクラスに分離したりするなどしてメンテナンス性を損わないようにしましょう。

<a name="inheritance"></a>
### 継承の使いどころ

継承は、本当にすべきかどうかをよく考えてからにしてください。`is-a` と `has-a` の違いについて調べてください。昨今の C++ で継承を利用すべきケースは初心者の方が思っているよりもかなり限られます。不用意な継承の使用は、著しくメンテナンス性の悪いコードへの第一歩となります。

仕方なく継承を使うケースとして、多態 (polymorphism) が挙げられます。多態とは、ここでは、基底クラス型のポインタに、複数の派生クラス型のオブジェクトポインタを格納し、同じメンバ関数呼び出しでもオブジェクトの実際の型によって異なる挙動をさせる使い方を指します。多態させるメンバ関数と、デストラクタは、 virtual メンバ関数にすることを忘れないでください。C 言語だと `union` を使って行うような処理ですが、その場合は自分で型を判定できる要素を用意し、それを用いて条件分岐して挙動の変化を実現します。virtual メンバ関数を定義してしまうと、オブジェクトは vtable という構造を持ち、関数呼出時に型によって処理を分岐するようになるため、オーバーヘッドが発生しますので注意が必要です。逆に、virtual キーワードを指定しない場合、あるコードにおいて用いられる型は静的に(コンパイル時に)決まってしまうため、同じ名前のメンバ関数だけれど、オブジェクトの実際の型によって中身が異なるものを実行するという目的は達成できないでしょう。以下の例に挙動の違いを示します。

```c++
#include <cstdio>
#include <memory>

struct A
{
    virtual void f1() { :: puts("A::f1"); }
    void f2() { ::puts("A::f2"); }
    virtual ~A() noexcept {}
};

struct B : A
{
    void f1() { ::puts("B::f1"); }
    void f2() { ::puts("B::f2"); }
    void f3() { ::puts("B::f3"); }
    ~B() noexcept {}
};

int main()
{
    A* p = new B;
    p->f1();
    p->f2();
    //p->f3();
    dynamic_cast<B*>(p)->f3();
    ((B*)p)->f3();
}
```
`A*` のポインタであったとしても、`f1()` は virtual メンバ関数なので、多態に相応しい挙動をし、`B::f1()` が呼ばれます。しかし、virtual ではない `f2()` は、`A*` の型だけ見てコンパイル時に呼ぶ関数を決定しますので、`A::f2()` が呼ばれます。`f3()` に至っては `A` で定義されてないのでキャストなしでは呼ぶことすらできません。それが `B` のオブジェクトであることを確信できる場合のみキャストを使えますが、それはすなわち、`p` が指しているオブジェクトの型が `B` であるかどうかを判別する明示的な条件分岐を必要とするわけです。

また、継承による多態を使うときに気をつけなければいけないこととしてデストラクタの virtual 化が必要になります。以下は悪い例です:

```c++
// 悪い例
struct A
{
  ~A() {}  // non-virtual destructor
};

struct B : A
{
   int *p;
   B() : p(new int(0)) {}
   ~B() { delete p; }
};

int main()
{
    A *a = new B();
    delete a;  // ~A() が呼ばれ、~B() は呼ばれないので、メモリリーク
}
```

この例では、`~A()` が virtual ではないので、`A*` 型の変数 `a` から `B` 型のオブジェクトを指しているとき、`delete a;` は `~A()` のデストラクタのみを呼んでしまい、メモリリークします。`~A()` に virtual を指定しておけば、ポインタの型 (`A`) ではなく、実体の型 (`B`) のデストラクタを呼んでくれます。`~B()` だけに virtual を指定しても `~A()` は自動的には virtual にならないため、やはりメモリリークしてしまうのが少しややこしいです。

C++17 では `std::variant` という型が導入されました。これはひとつの `std::variant` 型の変数に、複数の型のオブジェクト値を格納できる機能です。それらの型は継承関係を持つ必要はありません。これは C 言語の `union` と同じ仕組みを、C++ の型に合わせて実現したものです。Copyable class だけでなくて、Movable class のオブジェクトも格納できますので、使いどころはありそうです。ただ、オブジェクトの型を見て適切に処理を分岐するコードは自分で書かないといけない点が、継承を使った多態とは違うところです。

Mix-in は、virtual メンバ関数を使わずに、派生型でメンバ変数を新たに定義せず、メンバ関数だけを増やす手法です。派生型のデストラクタでは何もする必要がないので、基本型のデストラクタだけ呼ばれれば良いため、virtual デストラクタがなくても問題ありません。Mix-in は vtable を必要とするクラスが持つデメリットの影響を受けないので気軽に使えますが、使いどころは限られます。

異なる型だけれど、それらが同一のシグネチャを持つメンバ関数を持つことを保証させる機能をインターフェースといいます。C++ で継承を使ってインターフェースを実現するには virtual クラスを用いた多態をすることになります。インターフェース機能を使うなら、継承を使うよりは、テンプレートを使う方が良いかも知れません。ただし、テンプレートは静的に型を解決するので、使う型の数だけコードが増えるというデメリットもあります。

<a name="private-declaration"></a>
### private 宣言について

メンバ変数やメンバ関数を private にすることによって、オブジェクトの外からアクセスできないようにすることをカプセル化と呼んだりします。余計なものを見せないことで、オブジェクトの外と内の境界を、出来るだけ単純なものにし、メンテナンス性を担保する目的があります。逆にいえば、むやみに private 化するのもまた意味がないということです。

```c++
struct A
{
private:
    int i_;
public:
    void set(int i) { i_ = i; }
    int get() const { return i_; }
};
```

 こんなコードを書くくらいなら、素直に `i_` を public にして直接アクセスすれば良いですよね。入力をチェックする必要があるだとか、必ず加工してから出力するなどの理由があれば、メンバ変数を private に留める方が良い場合もあると思います。メンバ関数について、外に見せる必要がない、その他のメンバ関数からのみ呼ばれる部品としてのみ機能するものは private にしておくべきでしょう。

<a name="memory"></a>
## メモリ

<a name="new-and-delete"></a>
### new と delete

C 言語だとヒープメモリは `malloc` 関数を使って確保し、`free` 関数を使って解放するのが一般的です。`malloc`/`free` 関数は C++ でも使えますが、それとは別に `new` 演算子と `delete` 演算子が用意されています。`new`/`delete` はヒープオブジェクトの確保と開放を行う操作で、ヒープメモリの確保解放だけではなくコンストラクタ/デストラクタ呼び出しもするという点が `malloc`/`free` とは異なります。
最も大事な点は、`new` や `delete` を素で呼んではいけないことです。要するに以下のようなコードを書いてはいけません。

```c++
{
    A *p = new A;
    // p を使った操作
    delete p;
}
```

`malloc` や `new` で確保したヒープメモリやヒープオブジェクトは、スマートポインタを使って管理するか、管理のための専用ラッパークラスを定義すべきです。なぜならそうしないと我々はいとも簡単にメモリリークするバグを埋めこんでしまうからです。C 言語では注意深くコードを書かないとすぐにメモリリークしますが、C++ では上記の注意を守っていれば、まずリークしません。RAII がメモリを含むリソースのリークから我々を守ってくれるからです。

<a name="raii"></a>
### RAII によるリソースリークの防止

[RAII](https://en.cppreference.com/w/cpp/language/raii) とは、*Resource Acquisition Is Initialization* の略で、リソースの寿命をオブジェクトの寿命に合わせることで、リソースリークを多くの場面で防ぐことができる手法です。具体的には、リソースの確保をコンストラクタで行い、開放をデストラクタ内で行います。例外が飛んでも対応するスコープを抜けて寿命が尽きたオブジェクトのデストラクタは必ず呼ばれるので、開放し忘れることがないという仕組みです。リソースとして、メモリだけでなく、ロック、ファイルディスクリプタ、ネットワークコネクション、などなど様々なものを対象に出来ます。特に、長時間動作するサーバープロセスなどのプログラムでは、プログラムが使う全てのリソースに対して RAII を使うことを強くオススメします。必要があれば自分でラッパークラスを作ってください。これを徹底するだけで、我々は自動的にほぼリソースリークしないプログラムを手にいれることができます。例えば以下のコードを見てください:

```c++
void bad_code()
{
    A* p = new A;
    try {
        // 例外を投げるかも知れない操作
        delete p;
    } catch (std::exception&) {
        delete p;
        throw;
    }
}

struct SafeHeapA
{
    A* ptr;
    SafeHeapA() : ptr(new A) {}
    ~SafeHeapA() noexcept { delete ptr; }
};

void good_code()
{
    SafeHeapA s;
    // 例外を投げるかも知れない操作
}
```

`bad_code()` では、ヒープオブジェクトを作成して `p` から指すようにした後、常に例外発生の可能性に気を配ってコードを書き、最後にヒープオブジェクトを開放する責任が `bad_code()` 関数に生じます。しかし、`good_code()` のように RAII に従った `SafeHeapA` というラッパークラスを用意すれば、例外が投げられても `s` のデストラクタは必ず実行され、メモリリークは起きないですし、コードも読みやすくなります。

デストラクタ自身は例外を投げられないので、リソース開放処理中に発生した例外を検知、処理したい場合は、リソース開放を実行するメンバ関数(`close()` など) を用意して、`try-catch` 節内で明示的に呼び出す必要があります。そのようにクラスを設計したとしても、`close()` を明示的に呼び忘れたときのために、デストラクタでも `close()` を呼ぶようにして、万全を期すアプローチが有効でしょう。もちろん `close()` は複数回実行しても問題ないように設計するか、フラグ等を用いて実質一度しか呼ばれないようにしておく必要はあります。

```c++
struct A
{
    bool closed_;
    Resource resource_;
    A() : closed_(false), resourece(open_resource()) {}
    ~A() noexcept try {
        close();
    } catch (...)
    }
    void close() {
        if (closed_) return;
        close_resource(resource_);
        closed_ = true;
    }
};
```



<a name="smart-pointers"></a>
### スマートポインタ

C++11 以降でスマートポインタが使えます。`std::unique_ptr` と `std::shared_ptr` です。これらはヒープオブジェクトをラップし、RAII の恩恵を受けられる最も基本的なクラスです。簡単に説明すると、`new` 演算子で確保されたオブジェクトをスマートポインタに入れて管理すると、スマートポインタの寿命が来たときに、自動的にデストラクタが呼ばれ、その中で `delete` が呼ばれて指していたヒープオブジェクトが開放されるのです。

```c++
{
    std::unique_ptr<A> p(new A());
}  // p の寿命。p が管理していた A 型のヒープオブジェクトは p のデストラクタによって自動的に delete される。
```

スマートポインタは、変数の寿命とヒープオブジェクトの開放タイミングを一対一対応させ、開放忘れを防いでくれます。我々がコードを書くときに、特に何も注意しなくても、関数内ローカル変数の寿命はブロックの終わりで尽きることが多いですから、注意深く `delete` を実行するコードを手動で書くのに比べて圧倒的に安全です。

`std::unique_ptr` と `std::shared_ptr` は、オブジェクトをひとつの変数で占有するか、複数の変数で共有するかよって使い分けますが、`std::shared_ptr` を使う場面は多くないでしょう。ありがたいことに、生ポインタに比べて `std::unique_ptr` を使うために追加で必要なオーバーヘッドはありません。64bit アーキテクチャの場合、`sizeof(std::unique_ptr<A>)` は  64bit です。追加のコストなしに使えるので、ほとんどの場面でヒープオブジェクトの管理のため `std::unique_ptr` を使うべきです。一方、`std::shared_ptr` はオーバーヘッドなしとはいかず、コントロールブロックをヒープオブジェクト毎に持ち、それへのポインタを追加で持つため、`sizeof(std::shared_ptr<A>)` は大抵 128bit です。

`std::unique_ptr`  を使っていたとして、一時的に関数などに渡して使う場合は `std::unique_ptr` それ自身の参照渡しもしくは中身のポインタを生で渡せば良いですし、ムーヴを使うことで他の変数や参照渡しされた引数などに管理を移譲することもできます。所有と借用の概念については別途説明しますが、`std::unique_ptr` 自身もしくはそれを所有しているオブジェクトが所有者で、生ポインタや参照を持っているオブジェクトは借用者だと考えれば、オブジェクトの開放に責任を負っているのは所有者で、所有者の寿命が一番長くなるようにするか、所有者の寿命がもうないかもしれない場面でアクセスを避けることに気をつかえば、問題にはなりません。

スマートポインタを使いづらい場面があるかも知れません。生ポインタを使うことは確かに危険を伴いますが、利便性と安全性のトレードオフをうまく取るのが良い選択です。オブジェクトの寿命を意識し、ポインタの dereference (間接参照によるアクセス) を使うのはオブジェクトが生きている間だけ、という鉄則を守ってください。ほとんどの場合、専用のラッパークラスを定義して生ポインタを保持させ、デストラクタで開放するコードを書けば事足りるでしょう。プログラムの中で、そのような特別なケアをしなければならないオブジェクトはごく一部なので、気をつかうのもその周辺のコードだけで済むのは有り難いことです。問答無用で全てのヒープオブジェクトの寿命を手動管理させられる C の世界に比べれば天国です。

`std::shared_ptr` の使いどころがあるとすれば、誰が一番寿命が長いのかが自明ではないようなときで、かつリファレンスカウント方式の garbage collection を採用したいケースに限られるでしょう。たとえばマルチスレッドプログラムで、ふたつのスレッドが同一オブジェクトを `std::shared_ptr` で指していて、どちらかが先に寿命を迎えるか分からないようなときです。

ここまで説明しておいてなんですが、同一型の複数のオブジェクトをまとめて管理したいときは、STL のコンテナライブラリが役に立ちます。多くの場合、自分でヒープオブジェクトを確保してスマートポインタで管理しなくても、コンテナを使えば事足ります。コンテナはその内部で要素を格納する領域をヒープメモリから確保し、寿命が来たら デストラクタで必要な開放処理を行います。それらの挙動はもちろん RAII に従っています。

### 動的確保した配列よりも std::vector

配列の動的確保をするのにも `new` 演算子を使えますが、ほとんどの場合代わりに `std::vector` を使うべきです。
たとえば `int` 型の配列を動的に確保して使うことを考えてみましょう。`new` を使う場合は、
```c++
{
    // size_t n;
    std::unique_ptr<int[]> v(new int[n]);
    // v を使う。サイズが n であることは別途覚えておく必要がある。
}   // std::unique_ptr<int[]> のデストラクタが delete[] を呼ぶ。
```
と書きます。`std::unique_ptr` を使わないのであればメモリリークを防ぐために別途 RAII のためのラッパークラスを定義すべきです。ここでの `new` 演算子は先頭要素へのポインタを返すため、サイズ情報は自分で管理する必要があります。実質的には連続メモリ断片をひとつヒープ領域から確保しただけですから、コンパイル時に要素数やサイズが決まる配列とは違います。各要素はデフォルトコンストラクタで初期化されます(`int` の場合は `0` で初期化されます)。デフォルトコンストラクタを持たない型の動的配列はこの方法では確保できません。
`std::vector` を使う場合は、
```c++
{
    std::vector<int> v(n);  // 内部的に連続するヒープメモリを確保
    // v を使う。v.size() でサイズも分かる。
} // std::vector<int> のデストラクタがヒープメモリを開放
```
と書きます。デフォルトコンストラクタを持たない型でも、

```c++
{
    std::vector<A> v(n, A(arg0, arg1));
}
```
と書けば初期化できます。ただ、このコンストラクタを使った場合は `A` はコピーされてしまうので算術型以外の要素で使うのはあまりオススメしません。直接任意のコンストラクタを呼んで初期化したい場合は、
```c++
{
    std::vector<A> v;
    v.reserve(n);
    for (size_t i = 0; i < n; i++) {
        v.emplace_back(arg0, arg1);
    }
}
```
とすれば、ヒープメモリの確保は 1 回だけに抑えて、要素毎にコンストラクタを呼べます。他にも `std::vector` は便利なメンバ関数を色々と供えていますので、是非使ってください。

`std::vector` を使うデメリットがあるとすれば、`std::vector` は要素を格納するヒープメモリ以外に見かけ上のサイズと実サイズの 2 つのデータを保持しているため、同一サイズの動的配列を大量に作るときは、それらがメモリ容量のオーバーヘッドになるかも知れないことでしょうか。とはいえそのオーバーヘッドは一次元配列であれば無視できる程度だと思います。

二次元配列が作りたいなら、次のようにします。
```c++
size_t size0 = 10, size1 = 100;
std::vector<std::vector<int> > vv(size0);
for (size_t i = 0; i < size0; i++) {
    vv[i].resize(size1);
}
```
メモリ確保が面倒ですね。`new` を使う方法はさらに面倒なので省略します。次元が増えていくと、`std::vector` を使ったとしてもどんどん面倒になるので、サイズ固定の多次元配列を動的に確保したいなら、ひとつの `std::vector` の一次元配列を多次元配列に見立て、アクセス用のメンバ関数を用意した方が良さそうです。
```c++
class TwoDimensionalIntArray
{
    const size_t s0_, s1_;
    std::vector<int> v_;
    TwoDimensionalIntArray(size_t s0, size_t s1) : s0_(s0), s1_(s1), v_(s0 * s1) {}
    int get(size_t i, size_t j) const {
        assert(i < s0_); assert(j < s1_);
        return v_[i * s1 + j];
    }
    void set(size_t i, size_t j, int value) {
        assert(i < s0_); assert(j < s1_);
        v_[i * s1 + j] = value;
    }
};
```
このようなクラスは STL にはないですが、そこらのライブラリには用意されていますので、それを使うのも手です。

<a name="placement-new"></a>

### Placement new

特殊な用途なので、ここに書くか迷ったのですが、 `malloc` が通常保証する 8 bytes よりも大きな単位 (例えば 64B や 512B や 4KiB など) で alignment を揃えてヒープオブジェクトを確保したい場合があります。これを可能にするのは `posix_memalign()` や `mmap()` などの特殊な libc 関数やシステムコールです。それらを使ってヒープメモリを確保したのはいいですが、C++ オブジェクトとして振る舞って欲しい、すなわち、コンストラクタとデストラクタを呼びたいときはどうしたら良いでしょうか。そのような場合のひとつの手は、ラッパークラスを作って、そのコンストラクタ内でメモリを確保して placement new 演算子を呼び、ラッパークラスのデストラクタ内で元のクラスのデストラクタを明示的に呼んだ後に `free()` や `munmap()` を呼んでメモリを開放すれば良いです。

```c++
#include <cstdlib>
#include <new>

struct A {
    A() {  /* ... */ }
    ~A() noexcept { /* ... */ }
};

struct B {
    A *a_;
    B() : a_(alloc_and_cstr()) {
    }
    ~B() noexcept {
        a_->~A();
        ::free(a);
    }
    static A* alloc_and_cstr() {
        void *p;
        if (::posix_memalign(&p, ALIGNMENT, SIZE) != 0) {
            throw std::bad_alloc();
        }
        try {
            return new(p) A;
        } catch (...) {
            ::free(p);
            throw;
        }
    }
};
```
`new(p) A;` が placement new 演算子を使って初期化する操作です。Try-catch 節は `A` のコンストラクタが例外を投げるケースをカバーしています。注目しているコード上では例外が投げられる可能性があることが明示的には見えないのがこの問題を見つけにくくしていると思います。ただ、今回のようなカスタムでメモリ確保と初期化を行う必要がある場合は少ないですし。適切なデストラクタを持っているメンバ変数ならばまず問題ありません。逆にいえば、生ポインタのメンバ変数は、リークの回避が難しいのでご注意ください。上記の例は大丈夫ですが、例えば `A` のコンストラクタ内で例外を飛ばし得るコードを追加してしまうと、`A` のデストラクタは呼ばれず、このままではリークしてしまいますので、コンストラクタ内で適切に処理する必要があります。また、通常そんなことはしませんが、別のメンバ変数がもし存在し、`a_` より後に初期化しようとしたときに例外が飛んだ場合は、それを自分でキャッチして `a_` を手動で開放するなどの手当が必要になり、かなり面倒で読みづらいコードになると思います。自分でこのようなリソース管理のためのラッパークラスを作る場合は、コンストラクタでの例外処理に気をつかいましょう。

他の方法としては、自分で作ったカスタムアロケータを `std::vector` などのコンテナに使わせる方法があります。こちらの方が簡単かも知れません。

<a name="variables"></a>
## 変数

変数はデータを格納する箱と説明されることが多いです。ある型のデータを入れることを想定した連続メモリ領域のことを[オブジェクト](https://en.cppreference.com/w/cpp/language/object)と呼びます。変数はオブジェクトに名前をつけたものというのが、正確ではないかも知れませんが分かりやすい説明かと思います。オブジェクトには対応する型の具体的なデータ、すなわち値が格納されます。C++ における変数は値型変数、ポインタ型変数、参照型変数の 3 種類があります。値型変数は、対応した型の値が格納されます。算術型 (arithmetic type) の値 (int 型の 1 や float 型の 2.3 など) や、クラス型であればその具体的なインスタンスの値です。ポインタ型変数は、オブジェクトの位置を表わすメモリアドレスを格納します。メモリアドレスが格納される領域もオブジェクトとして扱います。つまり、ポインタ型変数にとっての「値」はメモリアドレスということになります。例えば `int **a;` は 「`int` オブジェクトを指しているポインタ型オブジェクト」を指しているポインタ型オブジェクトに `a` という名前がついていることになり、二段階の関節参照を意味しています。参照型変数は既に存在するオブジェクトの別名という扱いです。型についての詳しい分類が[ここ](https://en.cppreference.com/w/cpp/language/type)に書いてあります。その説明によればオブジェクト型はポインタ型を含みますが、参照型は含みません。関数の参照型引数やクラスの参照型メンバ変数はアドレスを格納しますので、これらの場合はポインタと大体同じものだと思ってもらって構わないと思います。

プログラムから見える、オブジェクトが配置されるメモリ領域には、静的領域、スタック領域、ヒープ領域の 3 つがあります。グローバル変数やファイル内ローカル変数は静的領域に、関数内ローカル変数はスタック領域にデータが格納されます。関数呼び出しの度に、呼び出し側のローカル変数を保持したままで新しいローカル変数用の領域を用意する必要があるため、スタックは伸びます。逆に、関数呼び出し完了の度にそのローカル変数は寿命を迎えて不要になるのでスタックは縮みます。ヒープ領域にはオブジェクトを配置できますが、それを指して使うには、ポインタ型変数や参照型変数が必要になります、つまりグローバル変数やローカル変数から辿れるようになっていないと使えません。オブジェクトが配置される領域によって、スタックオブジェクト、ヒープオブジェクトなどと区別することがあります。

### オブジェクトのメモリイメージ

C++ を扱うならば、是非オブジェクトのメモリイメージを意識してもらいたいです。例えば、以下のようなクラス `A` を考えます。
```c++
struct A
{
    int i;
    int j;
};
```
`A` のインスタンスオブジェクトは、コンパイラやそのオプション次第で変わり得ますが、通常 4 + 4 = 8 bytes のデータを持つ連続メモリ断片となります。つまりコンパイル時に型のサイズ `sizeof(A) == 8` が決まります。連続メモリ断片と呼んでいるのは、プロセスメモリ空間上で、ひとつのアドレス範囲で表現できるメモリ領域ということです。CPU アーキテクチャが x86_64 などの little endian であれば、たとえば、`int` 型の `1` は、`0x01`, `0x00`, `0x00`, `0x00` という順序で 1 byte ずつ計 4 bytes 配置されます。算術型など CPU がそのまま扱える型は、どのような値がどのようなバイト列になるのか、CPU によってフォーマットが決まっています。一般に異なるアーキテクチャの CPU 同士では互換性はありませんが、`int` などの基本的な型は big endian か little endian くらいの違いしかないことがほとんどです。

以下のクラス `B` はどうでしょうか。
```c++
struct B
{
    int i;
    int j;
    A *a;
};
```
`B` のインスタンスオブジェクトは 64bit アーキテクチャでは通常 4 + 4 + 8 = 16 bytes のデータを持つメモリ断片となります。つまり `sizeof(B) == 16` ということです。ポインタ型メンバ変数 `*a` は別のメモリ領域にある `A` 型オブジェクトを指し得ます。ひとつの連続メモリ断片としての `B` のインスタンスオブジェクトには `*a` が指す `A` 型オブジェクトのアドレスは含んでいても、オブジェクトの値そのものは含まれないことに注意してください。それは一般に、離れたアドレス上に存在する別の連続メモリ断片です。よく連続メモリ断片としてのオブジェクトを四角形で、ポインタを矢印で表してその構造を図示したりします。`a` が `nullptr` でない `B` オブジェクトを図示すると、四角形が 2 つで、それが矢印ひとつで結ばれている図となります。文脈によっては、ポインタ型や参照型のメンバ変数が指しているオブジェクトも含めて広い意味でひとつの「オブジェクト」と考える場合もあります。

<a name="scope-and-lifetime"></a>
### スコープと寿命

[スコープ](https://en.cppreference.com/w/cpp/language/scope)とは、変数にアクセス可能なコード範囲のことです。スコープにはいくつか種類がありますが、代表的なものは、ブロックスコープ、関数スコープ、関数パラメータスコープ、クラススコープなどです。大雑把な理解の仕方として `{}` で囲まれた領域はスコープです。変数の[寿命](https://en.cppreference.com/w/cpp/language/lifetime)は変数が宣言されてから、対応するスコープの終わりまでです。なぜスコープや寿命を意識する必要があるといえば、それらの終わりで変数に格納されているオブジェクトのデストラクタが暗黙的に呼ばれるからです。我々の思い通りにリソースをコントロールするために、我々は変数の寿命がいつ来るかについて知っておく必要があります。昔の C と違って、C++ ではブロックや関数の途中でも変数が宣言できますので、必要なときに宣言することで、スコープを可能な限り小さくすることができますし、メンテナンスの観点からもそうすべきです。

注意点として、`new` で確保したヒープオブジェクトのアドレスを生ポインタに格納し、その変数が寿命を迎えると、それが指していたヒープオブジェクトはリークします。ヒープオブジェクトに元々寿命はないのです。オブジェクトのリークとは、そのオブジェクトをもはや誰も使わないのに、期待を裏切って開放されずにメモリを占有し続けてしまうことをいいます。これは明らかにバグですね。何故リークしてしまうのかといえば、生ポインタにはデストラクタなどなく、それが指しているヒープオブジェクトを開放する責任がないからです。明示的にヒープオブジェクトを所有させ、寿命と共に `delete` させたいときはスマートポインタを使いましょう。スタックオブジェクトは関数呼び出しが完了すれば自動的にスタックが縮むことにより使っていたメモリが再利用可能な状態になりますので、心配はいりません。

関数が値返しであるならば、そのオブジェクトはたとえ関数内ローカル変数(関数内で定義され、関数の終わりでスコープが終わり、本来であればデストラクタが呼ばれる)だったとしても、関数の返り値を受けとる変数にコピーやムーヴされることがあります。C++ では条件にもよりますが最適化によって コピーやムーヴが省略されます。つまり、格納される変数は関数内のものから呼出側のものへと変わりますが実質的にオブジェクトの寿命が延びるわけです。C++17 ではこの返り値関連の最適化を含む [copy elision](https://en.cppreference.com/w/cpp/language/copy_elision) が義務化されました。

関数によって値返ししたり、コンストラクタを直接呼び出して作ったオブジェクトなどは一時オブジェクトと呼ばれますが、一時オブジェクトの寿命はその使われ方によって変わります。通常、一時オブジェクトの寿命はそれを含む文が終わるまでですが、const lvalue reference または rvalue reference で受けたときは、その変数のスコープまで寿命が延びます。ここで注目している一時オブジェクトはあくまでスタックオブジェクトで、ヒープオブジェクトではないことに注意してください。

<a name="variable-initialization"></a>

### 初期化

オブジェクトの[初期化](https://en.cppreference.com/w/cpp/language/initialization)についても気をつける点があります。原則として変数宣言や領域確保から初期化までのタイムラグはゼロか、ごく短かくなるようにしましょう。算術型などでは C 言語と同じように、`int i;` のように初期化なしで宣言した場合は内容が不定になります。ヒープオブジェクトの場合も同様で、`int* i = new int;` と書くと不定となります。グローバル変数や static 変数など静的領域に確保されるものは `static int i;` などと宣言すると[ゼロに初期化](https://en.cppreference.com/w/cpp/language/zero_initialization)されます。算術型をメンバ変数に持つクラスでも、コンストラクタの初期化子を使って初期化しないと不定になります。たとえば `struct A { int i; };` における `i` は `A` の初期化後も不定です。そのような細かい知識を知らなくても安全なプログラムを書くために、明示的な初期化を心がけることをオススメします。明示的な初期化とは以下のような操作です:

1. 宣言だけでは初期化されない型は初期値を明示的に与えて宣言/確保する。例: `int i = 0;`、`int* i = new int(0);`
2. 宣言だけでは初期化されない型をメンバ変数に持つクラスは、コンストラクタの初期化子で明示的に値を与える。例: `struct A { int i; A() : int(0) {} };`
3. メンバ変数の初期化が保証されていない型を使う場合は、与えられた手段で宣言/確保後出来るだけ速やかに初期化する。必要があれば自動で初期化を行うラッパークラスを作る。

明示的に初期値を与えたくない場合があるとすれば、それはコピーや計算結果の代入など他の手段で初期化する予定で、最初に `0` などを設定するのは無駄であり、性能に影響する、というケースでしょうか。分かって使う分には問題ありませんが、メンテナンス性の上で、不定な値にアクセスするリスクがあるという認識は持っておいてください。また、他人の書いた変数宣言やクラス定義のメンバ変数とコンストラクタを見て、宣言/確保時に不定なのか不定でないのかを判断するクセがつくと良いと思います。

C++11 からのユーザー定義型オブジェクトの初期化に関する注意点としては、`A a;` のような何も指定しない初期化 (default initialization)、`()` による初期化 (direct initialization)、 `=` による初期化 (copy initialization) に加えて、`{}` による初期化 (list initialization) も使えるようになったことです。Direct initialization はコンストラクタに引数を与えて初期化するごく普通の初期化方法です。Copy initialization はコピーコンストラクタやムーヴコンストラクタを使う初期化です。List initialization はコンテナ型のオブジェクトにおいて `std::initialization_list<T>` で受けるコンストラクタを用意しておいて、同じ型の要素を並べて初期化に用いるのが典型的な使い方のようです。

<a name="having-and-borrowing"></a>
### 所有と借用

C++ で明確に定義されているわけではないと思いますが、プログラムを設計実装する上で重要な概念だと思うので、ここで、所有と借用について説明しておきます。

所有とは、所有者が、所有される対象リソースの開放に責任を持っていることを指します。所有者の関係として考えられるのは、変数とそれが指しているオブジェクトだったり、オブジェクトとそれが管理しているメンバ変数などのリソースだったりします。あるリソースがあったとき、それを開放するのはひとりだけですから、明示的にせよ潜在的にせよ、所有者は原則ひとりだけということになります。C++ においては、RAII を使ってコンストラクタでリソースを確保し、デストラクタで開放するクラスを設計した場合、そのインスタンスオブジェクトは、まさに当該リソースを所有していると言えるでしょう。値型変数は、寿命が来たときにデストラクタを呼ぶことから、格納しているオブジェクトを所有していると言えるでしょう。自分でリソース確保したわけでなくても、他のオブジェクトからムーヴされたリソースがあって、それを自分のデストラクタで開放する必要がある場合、そのオブジェクトは、当該リソースを所有していると言えるでしょう。また、オブジェクトはそのメンバ変数(が指しているオブジェクト)を所有しているといえるでしょう。*has-a* 関係と言われるわけですし、デストラクタでメンバ変数のデストラクタが呼ばれるわけですから、開放に責任を持っているわけです。さらに、生ポインタや参照が指しているヒープオブジェクトについて考えてみましょう。ポインタや参照はあくまでオブジェクトを指しているだけですし、複数のポインタや参照がひとつのオブジェクトを指していることもあります。しかし、誰かがオブジェクトを開放しなければ、それはリークしてしまうわけなので、期待されるべきこととして、誰かが開放に責任を持っていることになり、潜在的であったとしても所有者がひとりいると考えることができます。

借用とは、自分は所有者ではないけれど、対象のオブジェクトやリソースを指していて使う行為を指します。C++ においては、ポインタ型変数や参照型変数とそれが指しているオブジェクトが、多くの場合、借用関係にあたると考えられます。先程の例で、複数のポインタがひとつのヒープオブジェクトを指しているとき、ひとりは所有者で、残りは借用者というわけです。

所有と借用の例で分かりやすいのが `std::unique_ptr` でしょうか。以下に例を示します:

```c++
{
    A* b0, b1;
    {
        std::unique_ptr<A> a0(new A);  // a0 が所有者
        b0 = a0.get();   // b0 は借用者
        std::unique_ptr<A> a1(std::move(a0));  // a0 から a1 に所有権が移動
        // a0 には nullptr が入っている
        b1 = a1.get();   // b1 は借用者
        // b0 も b1 も a1 と同じヒープオブジェクトを指している。
    }  // a0 は nullptr を指しているので何もしない。a1 のデストラクタでヒープオブジェクトを開放。
    // b0 および b1 は dangling pointer になる
}
```



RAII パターンは、リソースの寿命を変数の寿命と合わせることで、所有者であることを明確にする役割があると思います。ある変数が、あるリソースを唯一指している状況にも関わらず、その開放に責任を持っているという自覚なしにコードを書けば、リソースリークしやすくなってしまいます。また、借用者である変数が、その所有者よりも寿命が長いとき、その指している先が不正なメモリ領域である状態が発生します (dangling pointer/reference)。それにアクセスしてしまうとセグメンテーションフォールトなど不正な動作をします。すなわちバグです。

バグの少ないコードを書くために、所有者と借用者の区別をしっかりとつけて、所有者はリソースを責任をもって開放すること、所有者よりも借用者の寿命が長くならないように心がけましょう。C++ では実際の開放はほとんどの場合デストラクタに任せれば良いので、専ら気にすべきなのは dangling pointer/reference ですね。Rust などでは所有の概念を言語機能として持ち、プログラマに強力な制約を課してくるようですが、C++ はあくまでそれを助ける機能が存在するという印象です。自由には責任が伴う、ということですね :)

<a name="exception"></a>
## 例外

<a name="exception-introduction"></a>
### 例外の概要

C++ の例外は、大域脱出の手段です。例外オブジェクトを作成し、`throw` 文で投げます。`try` 節の中で投げられた例外オブジェクトは呼び出し側を辿ってスタックを巻き戻し、最初に `catch` 節(例外ハンドラ)が定義されているところまで処理を飛ばします。ただし、`throw` 文を投げる時点で生きていたスタックオブジェクトで、例外ハンドラに到達するまでの間にスコープを抜けて寿命を終えたものを対象としたデストラクタの呼び出しだけは必ず実行されます。

スレッドの一番上の呼び出し側コード(メインスレッドの場合は main 関数)に至っても例外ハンドラが定義されていない、すなわちその例外を投げたコードはどの `try` 節にも含まれていなかった場合、プログラムは強制終了します。マルチスレッドプログラムの場合、ひとつのスレッドで例外をキャッチしそびれるとプロセスまるごと死にます。STL も例外を飛ばす可能性がありますから、例外は常に飛ぶ可能性があると考えて、コードを書くようにしましょう。つまり、一番上の呼び出しコード (main 関数やスレッドの起動時に実行する関数) で例外ハンドラを定義するのを忘れないようにしましょう。STL で投げられる例外や、お行儀の良い大抵の例外型は `std::exception` を継承していますので、それで受ければほぼ全ての例外がキャッチできます。例外を飛ばさないのは、C 言語互換の関数と、`noexcept` 指定で例外を飛ばさないことが明示されている関数だけで、それ以外は全部飛ばす可能性があるものとして扱いましょう。

問題点として、例外の仕組みの実現にはコストがかかります。バイナリサイズが増えるし、遅いです。その原因は大域脱出の仕組みだったり、途中経路のデストラクタ呼び出しのための処理だったりするようです。

例外がどこで発生したのかを知る方法は標準では用意されていません。自分で問題を解析するために必要な情報を例外オブジェクトに付加する必要があります。たとえばデバッグが目的ならスタックトレース情報などが欲しくなるでしょう。標準ライブラリではありませんが、例えば、[cybozulib](https://github.com/herumi/cybozulib/) の `cybozu::Exception` は `throw` 時のスタックトレースを例外オブジェクト内に保持し、例外ハンドラでそれを参照できる機能を持っています。

<a name="exception-in-destructor"></a>
### デストラクタ内で発生した例外処理

例外を投げている途中に例外が投げられたらどうなるでしょうか？そのようなことが起こり得るのは、オブジェクトのデストラクタ内の処理です。例外が投げられても、スコープを抜けたオブジェクトのデストラクタは必ず実行されるのでした。例外が飛んでいる最中のデストラクタ処理で、デストラクタの外に新たな例外が投げられることが分かったときにプログラムは強制終了されます。逆に言えば、デストラクタ内で例外が発生しても、例外ハンドラをデストラクタ内に定義しておいて、例外処理すれば、プログラムは続行できます。

このような理由から、デストラクタ実行中に発生した例外の処理はほぼ握り潰さざるを得ませんが、それをどう扱うかはプログラム設計における選択になります。以下に例を挙げますが、敢えてログを吐くか(`~A()`)、潔くプロセスを自分で殺すか(`~B()`)、無言で握り潰すか(`~C()`)、などの選択肢があります。握り潰すとは例外をキャッチしておいて何もしないことです。

```c++
~A() noexcept {
    try {
        // try to deallocate resources...
    } catch (std::exception& e) {
        try {
            // try to put logs.
        } catch (...) {
            // do nothing
        }
    }
}

~B() noexcept {
    try {
        // try to deallocate resources...
    } catch (...) {
        ::exit(1);
    }
}

~C() noexcept {
    try {
        // try to deallocate resources...
    } catch (...) {
        // do nothing
    }
}
```

<a name="exception-and-return-value"></a>
### 例外と返り値エラーの使い分け

例外は便利ですが、重たいというデメリットもあるため、使いどころには注意した方が良いでしょう。発生頻度の高く、例外処理が性能に影響を及ぼし得るエラーについては、例外を使わずに返り値や参照引数でエラー情報を呼び出し側に伝え、エラー処理を行う方が良いでしょう。

C++ でプログラムを書き、STL のコンテナなどを使う時点で、`std::bad_alloc()` が投げられる可能性は常にあります。しかし、`std::bad_alloc()` が投げられたらまともにプログラムを動かし続けることは難しいと思います。そういう意味では、C++ は C よりもメモリにシビアな環境で動かすのは難しいのかも知れません。そのような環境を前提に C++ でプログラムを開発する場合は、例外や STL 等を使わないなどの特殊な使い方をする場合があるかも知れませんが、本ドキュメントで対象としている C++ の便利さを享受できなくなるのが辛いところです。

<a name="exception-spec"></a>
### 例外仕様

C++ の関数には、例外の種類を列挙させ、それ以外は投げられないことを示すインターフェースがあり、例外仕様と呼ばれていたそうです。具体的には `void f() throw(std::runtime_error);` といったものです。しかし、C++11 で例外仕様は非推奨になり、C++17 では削除されました。どうやら多くのコンパイラがこれを真面目に実装せず、単に無視されるだけだったようです。代わりに C++11 では `noexcept` キーワードが導入されました。これは、例外が投げられるのを許可するかしないかだけを指定するより単純なものです。`noexcept` を指定した場合は例外が投げられるのを許可せず、実際に投げられたら、呼出側に例外ハンドラが定義されていたとしても、即座にプログラムは強制終了されます。`noexept` を指定しない場合は、例外は投げられ得るものと見做されます。この情報は例外処理の最適化に使われるようです。

デフォルトのデストラクタが `noexcept` かどうかは[ここ](https://en.cppreference.com/w/cpp/language/destructor)に書いてあるように、条件によって決まるようです。自分で定義したデストラクタには `noexcept` を付けておき、例外を漏らさないようにするのが無難でしょう。

C++17 以降 `noexcept` 指定が関数の型情報に含まれるようになったので、関数ポインタを扱うときはその型に注意しましょう。`noexcept` の有無のみ異なるオーバーロードは許されないようですが、`noexcept` 指定した関数ポインタに `noexcept` でない関数は代入できなくなるようです。

<a name="pointer-reference"></a>
## ポインタと参照

改めて説明しますが、ポインタ(ポインタ型変数)とは、ヒープオブジェクトやスタックオブジェクトのメモリ上の位置、すなわちアドレスをデータとして格納する変数です。ポインタは C 言語でも使いますし、解説もたくさんありますので、これ以上はここで説明しません。
参照は、プログラミングをする上で実質的にポインタに似た性質を持つものであると見なして構いません。しかし、C++ に慣れた人はポインタよりも参照を多用します。

<a name="reference"></a>
### 参照の価値

参照は、ポインタと同様に、あるオブジェクトを指しているだけですが、ポインタと違って、値型変数と同様の操作ができます。

`A` という型があったとします。

```c++
A a;  // normal variable
A& ref = a;  // reference variable
A* ptr = &a;  // pointer variable

ref.func();
ptr->func();

A* ptr2 = &ref;  // アドレスも取れます

// ref = nullptr; // 不可能
ptr = nullptr;
```

参照 `ref` は `.` 演算子でメンバにアクセスできますが、ポインタ `ptr` は、それが実在するオブジェクトを指しているときに限り `->` でアクセスする必要があります。もしくは明示的に dereference して `(*ptr).func();` などとアクセスできます。参照は、値型変数と同様に `&` でアドレスも取れます。参照は、その宣言時に必ず初期化を必要とし、実在するオブジェクトを必要とするだけでなく、参照先を後から変更することもできません。つまり、参照は常に初期化時に指定されたオブジェクトを指しています。ポインタは宣言と初期化を分離できますし、代入によって自由に指すオブジェクトを変えることができますし、`nullptr` を格納できる点が異なります。そうです、参照は `nullptr` を保持できません。つまり、どのオブジェクトも指していない、という状態を表現できません。表現力という点において参照はポインタに劣るのです。だがそれが良いのです。別の言い方をすると、参照は、dereference が保証されたポインタのように振る舞うとも言えます。

参照の寿命が、それが指しているオブジェクトの寿命と同じになるとは限りません。オブジェクトの寿命が参照より先に来てしまうことはあり得ます。そのような状況下で参照にアクセスすると、不定な動作を引き起こすでしょう。
```c++
A& f()
{
    A a;
    return a;
}
```
このコードはコンパイルできますが、明らかに変数 `a` の寿命は `f()` が完了した時点で尽きています。それなのに、`a` の参照を返してしまっているので、明らかに返り値は正しくない(`a` のデストラクタが呼ばれた後の、他の用途に再利用されたかも知れない)領域を指しており、バグです。ポインタでも同様のことが言えます。

### コピーセマンティクス

一般に、オブジェクトがコピー可能 (Copyable) であるときは、コピーコンストラクタとコピー代入演算子が定義されていて、それらの挙動はコピーであることが期待されています。以下の `C` のようなクラスが典型的な Copyable class です。

```c++
struct C  // Copyable class example
{
    // Default constructor
    C() = default;
    // Copy constructor
    C(const C& rhs) : C() { copy(rhs); }
    // Copy assign operator
    C& operator=(const C& rhs) { copy(rhs); return *this; }
    void copy(const C& rhs) {
        // rhs の中身を *this にコピー
    }
    C(C&&) = delete;
    C& operator=(C&&) = delete;
};
```

コピーコンストラクタやコピー代入演算子は、引数と返り値が参照となっています。

Copyable class は以下のように使えます。

```c++
void f(const C& c)
{
    // c を参照する
}

void g(C& c)
{
    // c を参照したり、更新したりする
}

struct A
{
    C c;
    const C& ref() const { return c; }  // const lvalue reference を返す
    C& ref() { return c; }  // lvalue reference を返す
};

int main()
{
    C c0;
    C c1 = c0;  // copy constructor が呼ばれる
    C c2;
    c2 = c1;  // copy assign operator が呼ばれる
    f(c0);
    g(c1);
    A a;
    const C& c3 = a.ref();  // const 版が呼ばれる
    C& c4 = a.ref();  // non-const 版が呼ばれる
    C c5 = a.ref();  // const 版、copy constructor が呼ばれる
    c5 = a.ref(); // const 版、copy assign operator が呼ばれる
}
```

`A::ref()` はオーバーロードされていてふたつの実体があり、引数や返り値に応じて適切なものが呼ばれます。

<a name="move-semantics"></a>
### ムーヴセマンティクス

C++11 で、ムーヴセマンティクスが導入されました。ムーヴとは、移譲とか、中身の移動、という操作を指します。これを所有権の移動と捉えても良いかと思います。従来の参照は `T&` という形だけでしたが、これに、`T&&` という新たな形が追加されました。`T&` を lvalue reference、`T&&` を rvalue reference と呼びます。 詳しくは [ここ](https://en.cppreference.com/w/cpp/language/reference) を見てください。

lvalue とか rvalue というのは、expression (式) の分類です。全ての expression は lvalue, prvalue, xvalue のいずれかひとつに分類されます。l は left、r は right の略、prvalue は pure rvalue の略、xvalue は expiring value の略です。lvalue と xvalue をまとめて glvalue、prvalue と xvalue をまとめて rvalue と呼びます。ものすごく大雑把に分類すると、名前がついてるのが lvalue で名前がついてないのが rvalue です。例を挙げると、lvalue は変数や、関数などで、アドレスを取れます。rvalue は即値、関数呼び出し(の返り値)などで、アドレスを取れません。詳しくは [ここ](https://en.cppreference.com/w/cpp/language/value_category) を見てください。

例外はありますが、大雑把に言うと lvalue reference `T&` は lvalue を受けることができます。(代入したり、関数の引数で受けとったりすることです)。rvalue reference `T&&` は rvalue を受けることができます。lvalue reference は関数の引数や返り値で使うだけでなく、参照型変数としても使います。rvalue reference は専ら関数の引数や返り値で使うことが多いです。

なぜムーヴセマンティクスは導入されたのでしょうか。それは、ムーヴをコピーと区別しながらも同様のインターフェースで記述したい、というのがモチベーションです。ムーヴ可能 (Movable) であるときは、ムーヴコンストラクタとムーヴ代入演算子が定義されていて、それらの挙動はムーヴであることが期待されています。以下のようなクラス  `M` が典型的な Movable class です。

```c++
struct M  // Movable class example
{
    // Default constructor
    M() = default;
    // Move constructor
    M(M&& rhs) : M() { swap(rhs); }
    // Move assign operator
    M& operator=(M&& rhs) { swap(rhs); return *this; }
    void swap(M& rhs) {
        // *this と rhs の中身を入れ変える。
    }
    C(const C&) = delete;
    C& operator=(const C&) = delete;
};
```

もちろん、Copyable かつ Movable というクラスも作れます。ムーヴ操作を、コピーと同じ挙動として実装しても意味としては問題ありませんが、一般には、ムーヴ操作は、コピー操作よりも低コスト、高速であることが期待されます。C++11 以降の STL コンテナは必ずしも Copyable な class でなくても Movable な class であればそれを要素として典型的な使い方が出来るようになっています。

Movable class は Copyable class と出来るだけ同じような使い方ができて、しかしコンパイラが挙動を区別できるような仕組みになっています。

```c++
void f(M&& m)
{
    M m1 = std::move(m);  // move constructor が呼ばれる
}

struct A
{
    M m;
    const M& ref() const { return m; }  // const lvalue refernece を返す
    M&& ref() { return std::move(m); }  // rvalue reference を返す
    // M& ref() { return std::move(m); }  // M& を返すものと M&& を返すものはオーバーロードできない
}

int main()
{
    M m0;
    // M m1 = m0;  // copy constructor は定義されていないのでコンパイルエラー
    M m1 = std::move(m0);  // move constructor が呼ばれる
    M m2;
    m2 = std::move(m1);  // move assign operator が呼ばれる
    M&& m3 = std::move(m2);  // rvalue reference で xvalue を受ける
    f(std::move(m3));  // m3 は lvalue なので std::move() で xvalue にする必要がある
    A a0;
    M m4 = a0.ref();  // non-const 版、move constructor が呼ばれる
    M&& m5 = a0.ref();  // non-const 版が呼ばれる
    const M& m6 = a0.ref();  // non-const 版が呼ばれる
    const M& m7 = static_cast<const A&>(a0).ref();  // const 版が呼ばれる
    // M& m8 = a0.ref();  // rvalue は M& では受けられないのでコンパイルエラー
    const A a1;
    // M m7 = a1.ref();  // const 版、copy constructor を呼ぼうとするが、後者がないのでコンパイルエラー
    const M& m8 = a1.ref();  // const 版が呼ばれる
}
```

`std::move()` はただのキャストですが、lvalue を xvalue に変換するという点で意味を持ち、オーバーロードされた別の関数を選択させます。逆に言えば、コンパイラが適切なオーバーロード関数を選択するために lvalue と rvalue(xvalue + prvalue) の区別はあると言って良いでしょう。考えられる全ての組み合わせを挙げたわけではありませんが、我々が movable class を使う場合は「移動」をしたいのであって、通常はごく一部の組み合わせでしか使いません。

上に挙げた例を見ると、オーバーロードで複数の参照型と const が使われている場合に、不可解な挙動をするようにも見えます。const でない変数 `a0` において `ref()` を呼び出す場合、`const M&` で受けようとしても `A&&` を返す non-const 版が優先されてしまいます。const 版を呼ぶには `static_cast<const A&>` を使う必要があります。この例では敢えてオーバーロードさせてありますが、rvalue reference を返す関数を定義するときは、lvalue reference を返す関数とオーバーロードさせるのはやめて関数名を分けるのが懸命でしょう。


<a name="pointer-and-reference-usage"></a>
### ポインタと参照の使い分け

ひとことで言うと、ポインタは `nullptr` を格納でき、参照は必ずオブジェクトを指します。だから、関数の引数で `nullptr` であることを許容しないときは参照で受け、`nullptr` を渡すことを許し、それに意味を持たせる場合はポインタで受けるという使い分けをすると良いでしょう。参照で受ける方が制約が強く、上記のルールに従ってコードを書けば、参照で受ける場面が一般に多くなると思います。参照で受ける場合は、`const T&` か `T&` か `T&&` のどれで受けるか迷うかも知れません。その場合、以下のように使い分けると良いでしょう:
1. 関数内で対象オブジェクトを変更しない場合は `const T&`
2. 関数内で対象オブジェクトを変更して、後で呼び出し側がそれを使う場合は `T&`
3. 関数内で対象オブジェクトをムーヴして、後で呼び出し側がそれを使わない場合は `T&&`

`const T&&` も指定できますが、まず使うことはないでしょう。一時オブジェクトなどの rvalue は `const T&` または `T&&` で受けられるからです。込み入った用途で使うことがあるようですが、それは、どの種類の引数をどの種類の参照が受けられるか、オーバーロードでどのシグネチャが優先されるか、などを熟知した人がとても特殊な用途で使うものでしょうから、今我々が気にする必要はありません。

メンバ関数がメンバ変数などのポインタか参照を返したいと思ったときに、どちらで返すのが良いでしょうか。これも同じ考え方で決めれば良いです。つまり、ポインタで返す場合は、`nullptr` が返るかも知れない、という情報を暗に使う人に伝えているのです。逆に` nullptr` が絶対に返らないなら、参照を返すインターフェースにすべきです。この使い分けをしっかりすることが、C++ で書かれたコードの可読性、メンテナンス性に大きな影響を与えると思います。

<a name="const"></a>
## const

### const を制するものは C++ を制す

[const や volatile ](https://en.cppreference.com/w/cpp/language/cv) キーワード は cv-qualifiers と呼ばれます。volatile は一部の特別な用途を除いてほぼ使わないので、ここでは気にしないことにして、const の有り難さについて説明していきます。const をうまく使うことで、コードの読み易さ、メンテナンスのしやすさは格段に上がると思ってください。const というのは我々がプログラム内の変数や関数に与える制約であり、const を使えばコンパイラがその制約を満たしているかどうかをチェックしてくれます。仮に const がなかったとしても C++ で作るプログラムに出来ることは変わりません。しかし、const を適切に使えば我々は const に大いに助けられていることを実感するでしょう。C 言語においても const は有り難いものでした。C++ にはメンバ関数によって振る舞いを自分で定義できるクラスがあり、これが const の仕組みを使うことでさらに強力に我々をサポートしてくれます。

### const の意味

const は constant の略で、不変の、という意味を持ちます。const を使うことで、変数やオブジェクトに「変えられないよ」という制約を与えることになります。別の言い方をすると、read-only という性質を持つわけです。人間というのは忘れっぽい生き物なので、昨日の時点で変えないと決めたものを、今日になると変えようとするコードを平気で書いてしまうものです。コンパイラが const の記述を見て、コラコラ、それは変えられないよ！と怒ってくれるので、我々は、ああ、そこには変えられないという制約を入れたんだった、と我に返ることができ、間違ったまま開発が進むことを避けられます。重要なことは、プログラムにおいて、データの変更よりも参照する(参照型変数と混同するのでややこしいですが、ここでは変更を伴わないアクセスのことです)ことの方が多いという事実です。const によりオブジェクトの変更が発生するコードを限定しておくことで、コードを読むときや変更するときに考えなければならないことがぐっと減ります。

### const 変数

変数の種類は 3 つあるのでした。値型変数、ポインタ、参照。これら全ての宣言に const をつけられます。ひとつづつ説明していきます。

値型変数を const として扱うときは、`const int i = 1;` のような宣言と初期化をします。こう書いたとき、変数 `i` は変更できません。変更できないとは、以下の意味を持ちます:

- non-const のものも含めてメンバ変数へのアクセスは全て const 扱いになり、変更できません。
- const メンバ関数は呼べますが、non-const メンバ関数は呼べません。
- 再代入はできません。そもそも宣言時の初期化以外の手段で値を設定できません。

クラス型 `A` の場合は、`const A a;` と宣言したとき、デフォルトコンストラクタが実行され、その後寿命が来るまで変更できません。通常は、コンストラクタに引数を渡して何らかの値を設定して使います。`const A a(arg1, arg2, ...);` のように。

ポインタの宣言では、const を付ける場所によって 2 通りの意味があります。`const A* const a;` と書いたとき、ひとつ目の const は、以下の意味を持ちます:

- (ポインタが指すオブジェクトの) メンバ変数へのアクセスは non-const のものも全部 const 扱いになり、変更できません。
- (ポインタが指すオブジェクトの) const メンバ関数は呼べますが、non-const メンバ関数は呼べません。

ふたつ目の const は、以下の意味を持ちます:

- 再代入できません。そもそも宣言時の初期化以外で値(アドレス)を設定できません。

二つ目の const を使うことはあまりありません。ポインタを使うときは、変数そのものが再代入可能かどうかよりも、それが指しているオブジェクトが変更できるかどうかに注目することが多いからです。

宣言した変数が const だった場合、周辺コードを修正しようとしたときに、我々はその変数は
「変更されない」ものとして扱って良いわけです。変更すべきでないと思って const で変数を宣言したけれど、後日、そのことを忘れて誤って変更しようとしたとき、コンパイラが怒ってくれますので間違いに気付きやすいのです。コードを読む人も、主にオブジェクトがどう変更されるかに注目して処理の流れを追うことが多く、変数が const 宣言してあれば、初期化時以外は注意の対象から外して良いと分かるので、負担が減ります。

<a name="function-parameter-return-value-const"></a>
### 仮引数や返り値の const

関数の仮引数に `const int i` と書くのは好みの問題ですが、どうせ値渡しでコピーされているので、呼び出し元には影響がありませんし、関数シグネチャも値渡しの場合は const のありなしで区別されません。関数内ではもちろん const 変数として扱われますが、インターフェースとしては違いがありませんので、私は値渡しの場合は const を付けないことにしています。もしどうしても const にしたかったら、`int i` と仮引数に書いておいて、関数の最初で `const int& j = i;` とでも宣言して `j` を使えばある程度目的は達成されるかも知れませんが、これはやりすぎかなと私は感じます。

関数の返り値にも `const int` と書けますが、手元でコンパイラを動かしてみたら、warning が出ました。返り値の場合は、`const int f()` と `int f()` のシグネチャの区別がされないだけでなく、挙動の違いも何もありません。つまり `const` を付ける意味がまったくありません。

関数の仮引数に `const int* p` と書いたとき、関数内では `p` が指すオブジェクトを変更できないことを意味します。呼び出し側は関数呼び出し後も `p` が指すオブジェクトが変更されていないことをほぼ確信できます。これがメンテナンス性にとても影響します。自分が読んでいる、または修正しているコードにおいて、関数呼び出しがあったとき、ポインタ渡しまたは参照渡しした変数の中身が関数呼び出しの前後で変わるかも知れないと分かれば、それがどう変わるのかを知る必要があります。実際は中身を変えていないとしても、引数に const がついていなければ、変えていないかどうかコードを読んで確認しないといけません。const がついていれば、その中身に立ち入ることなく安心して変えられていないことを信じられます。実は、無理矢理キャストすれば関数内でもオブジェクトを変更できますが、そんなことをするコードはお行儀が悪く、忌むべき存在です。const を適切に使った場合、`int* p` を引数として持っている関数は、 `p` が指すオブジェクトを変更することが想定され(条件分岐の結果変更しないケースはあるでしょうけれど)、`const int* p` を引数として持っている関数は、`p` の指すオブジェクトを変更しないことが分かります。ポインタ仮引数に関して、const の有無は異なるシグネチャとして区別されますので、`void f(const int* p)` 版と `void f(int* p)` 版は別の実体としてオーバーロード定義できます。

関数の返り値に `const T*` を返すとき(`T*` も同様ではありますが)、少なくとも関数内ローカル変数へのポインタではないことは確認しておいてください。寿命が尽きているオブジェクトを指しているポインタ/参照を dereference するのは明らかなバグですから。引数もしくはグローバル変数/メンバ変数に含まれるオブジェクト、それらが指しているヒープオブジェクトなどが指されているはずです。この const は、返った先でそれが指しているオブジェクトが変更されないことを約束します。`T*` を返してしまったらオブジェクトが変更されても文句はいえません。変更されたくない場合に const ポインタを返すことはよくあります。コードの影響範囲という意味において、`const T*` を返すか `T*` を返すかは明らかに後者の方が影響範囲は大きいと見るべきです。ただ、グローバル関数の返り値がポインタであるとき、const をつける意味は限られます。引数が const で変更する権限がないから、返り値にも const をつけているときくらいでしょうか。グローバル変数から辿れるオブジェクトを指している場合は、大体のケースで誰でも変更できますので、関数の返り値が const ポインタである意味があまりありません。その場合は関数側で const ポインタを返すのではなく、呼び出した側で返り値を受けとるのに const ポインタを使うのが良いかも知れません。そのコードでは変更しませんよ、という意思表示をすることの方に意味がありそうです。const ポインタを返す方法が多用されるのは、グローバル関数ではなくオブジェクトのメンバ関数で、メンバ変数へのポインタを返すときです。オブジェクト外の人に読まれるのは構わないけれど、変更されるのは拒否したいときに役に立ちます。

参照については、ポインタと同じなので、省略します。別途書いたように、`const T&` は多用しますが、`const T&&` はまず使われません。仮引数としての `const T&` は lvalue も rvalue も受けとれますから、通常困ることはありません。

### const メンバ変数

const メンバ変数とは、クラスのメンバ変数宣言において `const` を指定したものです。こうすると、コンストラクタの初期化子で初期化した後はオブジェクトの外はおろかメンバ関数内でも一切変更できなくなります。例えば、immutable objects (不変オブジェクト) を作る方法として、メンバ変数を全部 const にしてしまうという方法があります。こうすると、オブジェクト自身を const 変数として扱わなくてもメンバ変数が全て const なのだから一切変更できません。これはかなり極端な例だと思います。デフォルトコンストラクタで何もしないことにして(例えば、`struct A { A() = default; };` ) 、後でメンバ変数を `init()` などのメンバ関数で設定しようと思っていたら、メンバ変数は const にできません。この 2 つの例は極端なものですが、現実のクラスの多くはその中間の手段を選択することになるのだと思います。

### const メンバ関数

const メンバ関数はとても重要です。オブジェクトが const であるとき、すなわち `const T` 型であるか、`const T&` または `const T*` で指されているとき、その変数経由では、const メンバ関数しか呼び出しできません。つまり、クラスを定義するときは const オブジェクトの振る舞いを定義するために const メンバ関数と non-const メンバ関数を分けます。const メンバ関数内では、non-const メンバ変数であっても const 扱いになり、変更できません。ですから、const メンバ関数はオブジェクトの状態を何も変更できないことになります。これは const オブジェクトとして期待される振る舞いですね。例外として、実際は変更されるけれど、オブジェクトが変更されたと見做したくない場合、例えば mutex オブジェクトなどについては、`mutable` キーワードをつけてメンバ変数を宣言しておくことで、const メンバ関数の中で const 扱いになるのを回避できます。あくまで例外的な操作のためのものなので、多用は禁物です。

const メンバ関数は non-const メンバ関数とオーバーロードできますので、必要に応じて定義してください。以下のような例が挙げられます。
```c++
struct A
{
    std::string s;
    const char& get(size_t i) const { return s[i]; }
    char& get(size_t i) { return s[i]; }
};
```
const 版では const 参照や const ポインタを返すことによって、const オブジェクトとしての振る舞いを保つことができます。このようなオーバーロードは STL コンテナでよく使われています。

### const 教のお約束

C/C++  の const (もしくは他言語における同様の機能) を適切に使うことにより、コードの読み書きにおいて多大な恩恵を受けられると信じる宗教のことを const 教というらしいです。その教義は以下の 2 つだと思います:
1. 変更されないのに、const をつけずに放置してはいけない。
2. const がついているのに、キャストなどを使って無理矢理中身を変更してしまってはいけない。

これらは const の恩恵を受けるための「お約束」なのに、それを破ってしまうと、const で信頼されている世界が崩壊していまい、メンテナンス性を著しく下げることになってしまいます。お約束が守られていないコードのやりとりをしてしまったら、人間関係もひょっとするとむちゃくちゃになってしまいます。それは冗談だとしても、あなたがお約束を破るコードを書いてしまい、const の恩恵を理解している人が読んだときは、ものすごくがっかりされるか、ものすごく怒られるか、もしくは両方でしょう。肝に命じてください。

とはいえ、例外はあります。実際にはオブジェクトの一部を変更するが、コードの意味としてオブジェクトが変更されたとはみなすべきではないとき、キャストや `mutable` を使って変更することは許容されるでしょう。ただし、何故そうするかをコメント等で書いておかないとコードを読む人に誤解されるかも知れません。キャストは使い方によってはとても危険な操作なので、読む人も疑念を持って見るでしょうから。それから、スコープがとても小さい、高々数行の変数について、パっと見て実質的に const だということがすぐに分かるコードでも const を付けるべきかどうかという問いについて、私は別に見てすぐに分かるならそこまで気にする必要ないじゃないか、と思ったりはします。迷ったときは可読性やメンテナンス性という目的に合うかどうかを考えれば良いと思います。

const 教を無理に信じなくても、const が適切に使われるコードを読んだりメンテナンスする機会があれば、その有り難みを実感、納得でき、const をうまく使えるようになるでしょう。私は信者なのかって？原理主義というわけでもありませんが、初心者向けの本ドキュメントに const のことを力説するくらいには信者だと思います :)

## テンプレート

[C++ テンプレート](https://en.cppreference.com/w/cpp/language/templates)は、コードジェネレータであると同時にコンパイル時計算の手段でもあります。後者の役割は、テンプレートを使って実現するには不便すぎて一部の物好きのための機能としか思えませんでしたが、その役割は  `consexpr` が担いつつあるようなので、ここでは今後も典型的に使われるであろう前者の役割に注目します。

### 出来ること

テンプレートは、型を引数として受けとって、クラス(型)や関数をコンパイル時に生成するものです。型を具体的に示さずに、そのままクラスや関数のように記述することによってテンプレートを定義できます。もちろん、テンプレートに実際の型を渡して実体化するときに、その型が持っていない機能をテンプレートが使っていたら、コンパイルできずにエラーになります。

### 使い過ぎに注意

ベンチマークなどで設定パラメータを複数用意して実験することがあります。それぞれのパラメータ毎に `if` 文で動的に条件分岐するのは性能に影響が出そうだから嫌だな、と思ったことがあって、パラメータを最内ループで分岐させるのではなく、`main` 関数の最初で全部分岐させてしまい、それぞれのパラメータセットに特化したコードを実行するように、全部テンプレート引数として実装してみました。例えば以下のようなコードです:

```c++
tamlate <int A, int B, int C>
void disaptch3(const Option& opt)
{
    // A, B, C を条件として分岐する。
    // 条件分岐済みのコードが生成される。
}

template <int A, int B>
void dispatch2(const Option& opt)
{
    switch (opt.c) {
    case C1:
        dispatch3<A, B, C1>(opt); break;
    case C2:
        dispatch3<A, B, C2>(opt); break;
    // ...
    }
}

template <int A>
void dispatch1(const Option& opt)
{
    switch (opt.b) {
    case B1:
        dispatch2<A, B1>(opt); break;
    case B2:
        dispatch2<A, B2>(opt); break;
    // ...
    }
}

void dispatch0(const Option& opt)
{
    switch (opt.a) {
    case A1:
        dispatch1<A1>(opt); break;
    case A2:
        dispatch1<A2>(opt); break;
    // ...
    }
}
```

この例だとパラメータは 3 つですが、実際にはパラメータの数は 5 つくらいで、それぞれ 4 個くらいの値が存在していたでしょうか。・・・どうなったか皆さんもうお分かりですね？  4 の 5 乗個 = 1024 個程の似て異なるコードがテンプレートから生成され、本来なら数秒で済んでいたコンパイル時間が 10 分を越えたあげく、バイナリサイズが大きくなってしまいました。このように、組み合わせ爆発をするテンプレートを簡単に書いて実体化できますが、手に終えません。このような用途では、Just-in-time コンパイルの手段を模索するか、CPU の分岐予測を信じて通常の `if` 文を使うしかないでしょう。

### パーフェクトフォワーディング

パーフェクトフォワーディング (完全転送) は、lvalue reference で受ける実装と rvalue reference で受ける実装をオーバーロードしている関数があったとき、それをまとめてテンプレートで扱う仕組みです。ひとつなら 2 個テンプレート書けばいいじゃないかと思いますが、呼び出しが n 段になると 2 の n 乗個定義しないといけなくなり、実質不可能なので、このような機能が欲しくなるようです。やり方は簡単:

1. 型引数にして (ここでは仮に `T` とします)、
2. 自らは `T&&` で受け (const とか付けたらダメです)、
3. `std::forward` で包んでオーバーロードしている関数に渡す

これだけです。何故このような動作になるかを知りたい人は、他の資料か C++ 仕様を参照ください。私は知識が足りなくてうまく説明できませんが、このような挙動を実現したい人達が、関数やテンプレートのシグネチャマッチングルールなどをうまく設定したのだと思います。

### テンプレートの限界

C++ のテンプレートをコンパイル時計算(メタプログラミング)のための言語と見做した場合、それは関数型プログラミング言語のような特徴を持っています。繰り返し処理は再帰を使わないと実現できないだとか、条件分岐もテンプレートの特殊化によるマッチングなどを利用して行われるとか。元々は、複数型に対して同じ処理をするコードをまとめて記述したい、という素朴な目的で作られたものが、結果として、ほぼチューリング完全の能力を、あくまで私の主観ですが、使いやすいとは言えない状態で獲得してしまったように思います。C++ のような手続型スタイルで、繰り返し処理や条件分岐をコンパイル時に実行し、コード生成する、という形のメタプログラミング言語だったら、もっと使い勝手の良いものだったんじゃないかと思います。同じことを思う人は C++ 標準策定に関わる人達にもいるようで、C++11 で登場した `constexpr` や C++17 で導入された `if constexpr` (これは完全な形でのコンパイル時条件分岐ではないのが悲しいところです。。) などが、より使いやすいメタプログラミング手段の萌芽に見え、ひそかに期待するところではあります。

### テンプレートを駆使する方へ

ここまで読んでも「俺/僕/私は C++テンプレートを極めるんだ！」という勇敢な方や「C++ テンプレート駆使しないとどうやらやりたいことが出来ないようだ。。。」という気の毒な方は頑張ってください。私はあまり詳しくないので良い情報を提供できませんが、いくつか日本語でも書籍は出ているようです。[boost template metaplogramming](https://www.boost.org/doc/libs/?view=category_metaprogramming) にもライブラリがあります。


## メンテナンス性

本ドキュメントはメンテナンス性を重視しています。必ずしも C++ 特有の話ではないですが、C++ でコードを書く場合、一歩間違えると大変なことになる気難しい側面はありますので、ここでメンテナンス性についてもう少し具体的に考えてみたいと思います。メンテナンス性が良いとは、コードの読み手がより少ない労力や時間で必要な情報を得られることと、より少ない労力や時間で必要とするコード修正やテストを行えることだと思います。つまり、読みやすく、修正しやすいということです。定量的に示すのが難しいですが、長い期間使われるコードであればあるほど、コードやドキュメントのメンテナンス性の良さはソフトウェアのコスト対効果の向上に大きな貢献をします。コードを書くとき、レビューするときは、以下の複数の観点から、よりメンテナンス性の良いコードにするにはどうしたら良いかということを考えてください。

### 部品化

同じ処理が複数の箇所に存在しているとメンテナンス性に悪影響を与えます。**DRY** (Don't Repeat Yourself) 原則と呼ばれますが、コードだけでなくドキュメントやコメントも含めて情報の重複を避けることが求められています。ある箇所を修正したら、同じ情報が書いてある別の箇所も修正する必要がある場合、DRY 原則に違反しているといえます。部品化しましょう。部品化とは、複数の変数や引数をひとつのクラスにまとめたり、複数行のコードを関数として独立させたりすることです。コード量が単純に減ることで、潜在的にはコードを読む労力が減りますし、重複がないということは、修正の労力も減りますし、修正し忘れを防止できます。

制御構造がコードに埋もれるとメンテナンス性に悪影響を与えます。`if` や `for` などの制御ブロック内に、大量のコードがあったり、その場での入れ子構造が何重にもなっている状態は、制御構造を把握しづらくさせます。コードを読む場合、制御構造は今どこを読むべきかを判断するための重要な情報なので、埋もれると読みづらくなります。また、制御構造を変更・修正する場合、制御ブロック内に大量のコードがあると、これらの一部または全部を移動するテキスト編集が発生し、ミスが起きやすくなります。このような処理は、たとえ 1 回しか呼ばれないとしても、部品化を検討しましょう。

1 行の処理も部品化すべきでしょうか？ 場合によっては「すべき」といえます。たとえば、何をやっているか一見分からない処理が 1 行で書かれていて、そのような処理が複数箇所で行われていて、その処理を良い名前で表現できるときなどです。1 箇所でしか使わないなら、コメントにその名前を書いておくのでも良いでしょう。インライン展開されれば処理のオーバーヘッドはありませんので、余程大量に呼ばれる処理でなければ気にせず関数として切り出し、気になるのであれば明示的なインライン化をコンパイラにお願いしましょう。

度重なる修正でクラスにメンバ変数が増えすぎたとき、関数内で定義されるローカル変数が増えすぎたとき、ひとつの関数に渡す引数が多すぎるときも、部品化を検討しましょう。複数のメンバ変数をまとめて別のクラスに分離したり、複数のローカル変数や引数をまとめてクラスとして定義したり、関数内の一部の処理を別の関数として分離したり、です。あえて、具体的にどのくらいの数や量なら多すぎるのかについては言いませんが、あなたがコードレビューする立場であれば、多いな、と思ったら迷わずそれを指摘し、部品化するメリットデメリットについて議論するようにしましょう。

###  疎結合

メンテナンス性に強い影響を与えるのが関数やクラスなどの部品がより疎結合になっているかどうかだと思います。良い指標があるのか分かりませんが、例えば、公開しているメンバ変数や関数インターフェースが少なく、それを呼ぶ箇所が少ない方が疎結合でしょう。また、呼んでいる箇所の数が同じくらいだとしても、const 操作の割合が多い方が疎結合と言えるでしょう。同様に、関数の引数が少ない方が疎結合でしょうし、引数が const である割合が多い方が疎結合でしょう。より疎結合であれば、ある処理を追うときに読まなければならないコード量が減ります。


### 名前

変数、関数、クラスの名前は重要です。「名は体を表す」の諺通り、中身を読まなくてもその挙動を推測するのに役立ちます。とんちんかんな名前がついていると、読み手の誤解による混乱を招き、無意味な名前がついていることよりも悪い効果をもたらすことがあり得ます。良い名前をつけましょう。品詞の使い分けについては様々な場所で言及されていますので、ここでは議論しません。ラムダ関数が無名で許されるのは、パッと見れば内容が分かるくらい単純なもので、わざわざ名前をつけなくても内容の把握が簡単だからなのです。

### 型

QQQQQ

### コメント

型情報、コメントなどは読み手の理解を助けます。`auto` の使いすぎに注意と言ったのは、読み手が必要とする情報が隠れて見えなくなってしまう恐れがあるためです。コメントは、コードを読めば分かることは書かないようにしましょう。主に何故そうしたのか、コードを読んだだけでは分かりにくいと思われるときに書きます。複数のやり方があり得たがなぜそれを選んだのか、そのコードの実行結果は何をもたらすのか、生成物は何に使われるのか、などです。また、変数や関数の名前は長すぎるのも問題なので、それを補佐する目的でもコメントを使います。

## その他

ここでは、書いてみたものの分量が多くなかった雑多な話題について、まとめておきます。

### 入力のチェック

プログラム外部からの入力は、必ず動的に(実行時に)チェックしましょう。これがセキュリティの脆弱性を生まないための大原則です。入力データをチェックなしに実行することは危険です。入力が何らかの形で実行される恐れがある場合は、文字列エスケープなどの処理で危険な操作をされないようにする必要があります。また、入力データのサイズにも注意しましょう。必ず現実的な上限を設定しておき、それに従ってチェックすることが肝心です。バッファオーバーフローという古から使われる有名な攻撃手法は、まさに想定外の長い入力を与え、それをプログラムが受けいれてしまうことによって引き起こされます。

とはいえ、無闇に入力をチェックすると、チェックを無駄に複数回実施することになり、性能が低下してしまいますので、プログラムと外との境界についてはしっかりと意識してください。また、`assert` はデバッグやテスト用途で便利ですが、通常リリースビルドでは有効化されないものです。ですから、セキュリティのための入力チェックを目的としては使わないようにしましょう。

### コンパイラ特有の話

いくつかあるので列挙しながら説明します。

- GCC や Clang のコンパイラオプションには、 `-Wall -Wextra` を必ず付けて多くの warning を出してもらいましょう。そして、warning が出なくなるまでコードを修正しましょう。Warning が出るということはリスクのあるコードであることを意味しますし、たくさん warning が出る状態を放置すると、コード修正のときに邪魔になりますし、問題が埋もれて見過される原因になりますので、やめましょう。
- `-pedantic` は ISO C/C++ に準拠しない文法や記法は禁止するというコンパイラオプションです。場合によっては使いましょう。いわゆる GCC 拡張が使えなくなります。
- C++ 標準の話と、コンパイラが受けいれる記法や掃き出すコードの話と、CPU 内部でどう実行されるかの話は、繋がってはいますが厳密には違う世界の話なので、区別して考えましょう。例えば、メモリオーダーの話などがそれに当たります。
- Linux や Windows などの環境の違いによる long や unsigned long のサイズの違いには気をつけましょう。64bit Linux では、long は 64bit ですが、64bit Windows では 32bit です。64bit Windows の上で動く環境でも、64bit Cygwin では 64bit だったり、64bit MinGW では 32bit だったり、WSL ( (Windows Subsystem for Linux) ではやっぱり 64bit だったりします。これらの基本型のサイズのバリエーションは、LLP64、LP64、ILP64 などと呼んで区別するようです。Windows や MinGW は LLP64、Linux、Cygwin, WSL は LP64 です。
- ヘッダファイルは同じ内容が複数回読まれないようにファイル先頭に `#ifndef HEADER_NAME` `#define HEADER_NAME`と ファイル末尾に`#endif` を書くことで、一度しか読まれないことを保証する方法が昔は一般的でした。しかしこの方法は名前 (`HEADER_NAME`) の衝突や、`#ifndef` と `#endif` の対応がおかしくなり得るなどの面倒くささを抱えています。 昨今は、多くのコンパイラが `#pragma once` という記法をサポートしていて、ヘッダファイルの先頭にこれを 1 行書くだけで、一度しか読まれないことが保証されるようになりましたので、是非こちらを使ってください。
- マクロは、C 言語の時代から使えるものでしたが、プリプロセッサで処理され、ソースコード文法の解釈なしで文字列置換を基本とした処理がなされる仕組みなので、危険がいっぱいです。定数の定義にマクロを使う伝統もありましたが、C++ では適切な名前空間に const 変数を定義して使うようにしましょう。コードジェネレータとして使う場合は、テンプレートで代用できないかを検討しましょう。どうしても使わなければならない場面もあるとは思いますが、出来るだけ少なく留めるのが良いと思います。また、マクロはヘッダライブラリなども含めて名前空間がひとつしかないので、自分がマクロを定義するときは、多少長くなるのは仕方ないものとして、適切なプレフィックスやサフィックスを付けて名前が衝突しづらくなるようにしましょう。
- `inline` 指定では必ずしもインライン展開してくれるわけではないので、必ずインライン展開したい関数は、コンパイラに強制する必要があります。GCC や Clang だと `__attribute__((always_inline))` を使います。
- GCC や Clang でソースファイルをコンパイルするときに `-MMD` `-MP` の両方のオプションを指定しておくと、`make` コマンドが解釈できる依存関係ファイルを `.d` 拡張子のファイルとして出力してくれます。その一方で Makefile に以下のように書いておけばよろしく依存関係を解釈してくれます:
```makefile
  ALL_SRC=$(wildcard *.cpp)
  DEPEND_FILE=$(ALL_SRC:.cpp=.d)
  -include $(DEPEND_FILE)
```

### ヘッダとソース

ヘッダファイルは `.hpp` とか `.h` の拡張子を持ち、原則プロトタイプ宣言だけが書かれていて、ソースファイルは `.cpp` とか `.cc` の拡張子を持ち、関数やメンバ関数の実装が書いてあるものです。注意点として、テンプレートは、ファイルローカルでしか使われないものを除いてヘッダファイルに内容を記述しないといけません。また、インライン展開したい実装は、やはりファイルローカルでしか使われないものを除いてヘッダファイルに書く必要があります。ソースファイルに書いた実装は、LTO (Link-Time Optimization) の最適化を除いて、必ず通常の関数呼び出しとなります。`main()` 以外の実装をヘッダファイルに書くというスタイルもあり得ますが、複数の実行ファイルを生成する前提で、コード量が増えてくると、同じヘッダファイルに含まれる同じコードを複数回コンパイルすることになり、コンパイル時間が長くなってきてしまいます。インライン展開が必要なコードはプログラムの中でごくごく一部でしょうから、あとのコードは大人しくソースファイルに実装しましょう。

ヘッダファイルの仕組みは、歴史的経緯からこのような状況となっているもので、ヘッダの取り込み順序で挙動が変わってしまったり、複数回の取り込みによるコンパイル時間の増大などの問題があります。より現代的で便利なモジュールの仕組みを導入しようとする動きが C++ 標準の方であるようです。対象の公開範囲を調節するだとか、名前を適切に変えて取り込むだとかのメンテナンス性に直結する機能ですので、是非実現されて欲しいですね。

### ラムダ式

C++11 で搭載されたラムダ式は、ちょっとした即席の関数オブジェクトを作って関数に渡したいときに便利だと思います。ただ、やはり使いすぎは禁物です。というのは、ラムダ式の参照キャプチャを使うと、実質的にラムダ式の外側のスコープにアクセスできるからです。

```c++
void func()
{
    int i = 0;
    // ...
    auto predicate = [&i]() {
        i = 1;
    };

    predicate();
    // i == 1
}
```

この例くらいならかわいいものですが、ラムダ式が巨大化して、参照する変数も増えると、コードの見通しはかなり悪くなってしまいます。そうなる前に、一部をきちんと名前のある通常の関数として切り出すなどのリファクタリングを行うことをオススメします。

C++14 で追加されたジェネリックラムダ、C++17 で追加された `constexpr` ラムダなど、ラムダ式も機能が増えていますが、やはり実際にどんな挙動をするかを分かった上で、可読性についても十分考慮して使ってください。曖昧な理解のままで使うくらいなら使わない方がずっとマシです。

### auto や decltype

C++11 で使えるようになって、その後 C++14 や C++17 で改善され続けている [auto](https://en.cppreference.com/w/cpp/language/auto)や [decltype](https://en.cppreference.com/w/cpp/language/decltype) は、利用範囲が増えてきました。テンプレートを定義する場合は、これらを使わないと実装が難しいものもあるようですが、通常の関数内で、気軽に使うのはよく考えてからにしましょう。コードの可読性という視点では、明らかに分かるもの以外で `auto` や `decltype` を使うのはオススメできません。例えば、[range-based for loop](https://en.cppreference.com/w/cpp/language/range-for)  の要素を受ける変数宣言や、イテレータを返す関数を受ける変数宣言などは、人間が見ても型が推論しやすいでしょうから、`auto` などを使っても読み易さが落ちにくく、かつ長ったるい型名の記述が減って書く側も読む側もうれしいことでしょう。それからラムダ式に名前を付けるときは `auto` を使うのが典型的な使い方です。私はこの 3 つのケースについてはあまり気にせずに `auto` を使っています。繰り返しますが、型推論してくれるからといって安易に `auto` や `decltype` を使うのはやめましょう。

### コンテナとイテレータ

どのコンテナをどのように使うべきかについては、多くの資料がありますから参考にしてください。ある型のオブジェクトからなる集合を管理するコンテナとして `std::vector`、 `std::list`、 `std::deque` などがありますが、性能特性が違うので、アクセスの方法によって使いわけられるべきもの達です。また、`std::map` と `std::unordered_map` は key-value 型のデータを格納するためのものです。木構造か、ハッシュテーブルかで実装が分かれ、性能特性や能力も違います。コンテナのメンバ関数は、C++ 標準で計算量などの制約が付けられていたりします。例えば、`size()` メンバは必ず計算量 `O(1)` で実行できることなどです。標準で性能基準が定められているものは、実装も制約を受けていますので、コンパイラやそのバージョンによらず、性能特性が担保されることが期待できます。

イテレータについて重要なこととして、 `begin()` は閉区間 `end()` は開区間であることを覚えておいてください。範囲というものは、閉区間で始まり、開区間で終わるという扱いにするのが汎用的に便利かと思います。その理由は、範囲の分割や隣合う範囲の集約操作が簡単だからとか、`0` 始まりの for 文において終点と実行回数が一致するという分かりやすさもあるかと思います。一番基本的な `for` 文は、以下のように書くことが多いと思います:

```c++
{
    // size_t n;
    std::vector<int> v(n);
    for (size_t i = 0; i < n; i++) {
        // use v[i]
    }
}
```

閉区間で始まり、開区間で終わりますね。これは、`0`, `1`, ..., `n-1` までの `n` 回実行される for loop です。逆順のアクセスは、

```c++
{
    std::vector<int> v(n);
    for (size_t i = n; i > 0; i--) {
        // using v[i - 1]
    }
}
```

このように記述できます。これに慣れれば、始点と終点の扱いを気にする頻度が減り、典型的な操作においてはバグったコードを書きづらくなると思いますので、begin は閉区間、end は開区間のパターンを使うように心掛けてみましょう。

### テスト

様々なテストフレームワークがありますが、何を使うとしても CI でリグレッションテストを実行することを意識しておけば良いと思います。ごくごく単純なユニットテスト用途で十分なものとして、[cybozulib](https://github.com/herumi/cybozulib) の `test.hpp` をオススメしておきます。

```c++
#include "cybozu/test.hpp"

CYBOZU_TEST_AUTO(test_a)
{
    int i = 0; j = 0;
    CYBOZU_TEST_EQUAL(i, j);
    CYBOZU_TEST_ASSERT(i != 0);
}
```
このように書いてコンパイルすると、テスト成功時は 0 、失敗時はそれ以外が返る実行ファイルが出来ます。

環境の整備や初期化などが必要なテストは、もっと複雑な機構が欲しくなるかも知れませんが、必要に応じてスクリプトを作ったりして対応すれば良いと思います。実行したらテスト成功か失敗かが判別できる出力をし、自動化しやすい形でプログラムとして作っておくのが重要です。

### boost ライブラリ

[boost ライブラリ](https://www.boost.org/)は C++ の標準ライブラリではありませんが、一部の機能が C++ 標準に取り込まれた実績が多くあるライブラリです。つまり、boost に入っている機能は次世代の C++ 標準に取り込まれる可能性があります。

自分の使いたい道具が C++ 標準になくて、boost にあったなら、使いたくなるのは当たり前です。しかし、ちょっと待ってください。あなたの書こうとしているプログラムは何年使われるものですか？何年メンテナンスする必要のあるものですか？boost は先進的なライブラリなので、古いバージョンは新しいコンパイラでビルドできなくなるかも知れませんし、新しいバージョンの boost ライブラリは API が変わっているかも知れません。OS のパッケージシステムなどで提供される boost はバージョンがひとつしか選べないか、選べても少ないでしょうし、新しいバージョンの OS には新しい boost が入っています。あなたのプログラムのメンテナンスのことを考えて、boost を使うかどうかを決めると良いでしょう。boost のヘッダライブラリだけを使う分には、相対的には互換性問題が発生するリスクが少ないと思います。


## おわりに

⾊々と書きましたが、本当に C++ 初⼼者がこれを読んで初⼼者脱出できるのか。。。という不安もあります。多くの⼈のフィードバックを経て、叩かれ磨かれていくべきと思いますので、是⾮フィードバックを著者までお願いします。郷に⼊っては郷に従えの部分もあるでしょうけれど、どのような⾔語を使う場合でも、プログラムの設計における⼤事なことはあまり変わらないと思いますし、それを C++ においてはどのように実現するか、ということを重視して書いてきたつもりです。本ドキュメントによって、C++ でメンテナンスしやすく、安全で、速いコードを書く⼈が増え、C++ ⼈⼝が増え、C++ が栄えて私が C++ を便利に使える時代が続いてくれたらうれしいな、と思います。Rust や Go に浮気するかも知れませんがね ;)


## 更新履歴

- 2018-08-13 v0.4 表現の見直し、細かい間違いの修正
- 2018-08-10 v0.3  継承回り修正、追記
- 2018-08-07 v0.2  色々と追加、改善
- 2018-07-30 v0.1 最初のバージョン
