# C++ 初心者からの脱出

サイボウズ・ラボ 星野 喬

<a name="introduction"></a>

## はじめに

本ドキュメントは、C はある程度使ったことがあり、C++ を独学で学び始めた人が、やるべきではないことをいとも簡単にやってしまう状況を少し改善したいと思って書きました。コンパイルは通るけれど、明らかにバグっている、メンテナンス性が悪い、性能面で問題があるコードを書かずに済むようになって欲しいという気持ちが込められています。

C++ は歴史が長いからなのか、とにかく仕様が複雑で大量にあります。仕様を全部理解しないと C++ を使ってはいけないなんてことはありません。脳味噌の容量は有限なのです。一部の C++ を牽引発展させていく人達はそういうわけにもいかないでしょうが、単に良いプログラムを書きたくて C++ を使おうとする我々にとっては、出来るだけ少ない知識で、必要十分に便利な機能を使いこなすのが理想です。逆に、仕様で許されているからといって、やって良い、やるべき、とはならないことが多いのが初心者にとって辛いところだと思います。

本ドキュメントは C++ をまったく書いたことがない人向けではありませんので、網羅性についてはあまり重視していませんし、キーワードをいちいち説明していないこともありますので、適宜ご自分で調べてください。本ドキュメントでは、何故そう書くか、何故そうすべきなのかについて、特に私が強く思っていることを書きます。もちろん、全ての C++ プログラマが同意するような完璧なものではないと思いますが、私の C++ コードを書いたりレビューしたりのつたない経験から得たひとつの解釈ではありますので、参考にしてもらえれば幸いです。

以下の項目に同意する人は、本ドキュメントを読むべきだと思います:

- 動的メモリ確保といえば、`malloc` か `new` を使った動的配列だ。
- RAII という言葉を聞いたことがない、聞いたことあるけどよく分からない。
- 変数のスコープや寿命を意識してコードを書いていない。
- ポインタと参照の違いがよく分からない。
- `T&` と `T&&` の違いが良く分からない。
- const を使ったことがない、あまり使わない。

本ドキュメントでは、主に C++11 でサポートされる機能を対象にします。場合によっては C++14、 C++17、C++20 について言及します。サンプルコードは、比較的最近の GCC もしくは Clang でコンパイルできることを確認していますが、include 宣言などを省略したりしているので適宜追加してください。

まず前提として、C はある程度使ったことがある人を対象にしていますので、[C FAQ](http://www.kouno.jp/home/c_faq/c_faq.html) を眺めて復習してきてください。C++ のオンラインマニュアルとしてオススメなのは、[cppreference](https://en.cppreference.com/) です。日本語であれば [cpprefjp](https://cpprefjp.github.io/) を挙げておきます。サンプルコードを書いて実行してみたり、コンパイラによって出力されるアセンブラコードやバイナリコードを見てみることをオススメします。さらに詳しい挙動を知りたい場合は、C++ 標準のドキュメント([ここ](https://en.cppreference.com/w/cpp/links)にリンクがまとまっています)や、コンパイラのドキュメント([GCC](https://gcc.gnu.org/onlinedocs/)、[Clang](https://clang.llvm.org/docs/UsersManual.html))が参考になるでしょう。C++ と直接関係はありませんが、実際の挙動については CPU のインストラクションや、OS のシステムコールなどについて調べる必要があるかも知れません。

<a name="table-of-contents"></a>
## 目次

[TOC]


<a name="struct-and-class"></a>
## C++ クラスと C 構造体の違い

C++ クラスは C 構造体の概念を内包しています。[POD](https://en.cppreference.com/w/cpp/named_req/PODType) (Plain Old Data) class は C 構造体として C 関数に渡せる、`memcpy` でコピーできるなどの特徴を持ちます。C++11 では、POD の定義が [standard-layout](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType) class と [trivial](https://en.cppreference.com/w/cpp/named_req/TrivialType) class というふたつの概念で表現されるようになり、C++20 では POD よりも後者の概念が主体的に扱われるようになります。Standard-layout class は C 構造体として C 関数に渡せることを、trivial class は `memcpy` でコピーできることを念頭に定義がされています。

<a name="cstr-dstr"></a>
### コンストラクタとデストラクタ

C++ クラスはコンストラクタとデストラクタを持てます。コンストラクタはオブジェクトの初期化時に実行されるコードで、デストラクタは開放時に実行されるコードです。これらは返り値を持ちません。コンストラクタはシグネチャ(簡単に言うと仮引数の数や型)が異なれば複数定義できますが、デストラクタは引数を持たないものひとつだけです。特殊なコンストラクタとして、デフォルトコンストラクタ (`T()`)、コピーコンストラクタ(`T(const T&)`)、ムーヴコンストラクタ(`T(T&&)`) があります。

<a name="member-function"></a>
### メンバ関数

クラスにはメンバ関数を定義できます。メンバ関数は、そのオブジェクト特有の処理を行うときに便利です。また、メンバ関数の名前が、クラスを越えては見えないというメリットや、C 構造体の要素に相当するメンバ変数にアクセスできるメリットがあります。これはメンバ関数のスコープがクラススコープであるからです。メンバ関数の引数にはクラス外部のもののみ渡せばよいので、スッキリします。
ある処理をグローバル関数とメンバ関数のどちらにすべきかについて悩んだ場合は、それらのメリットデリットを天秤にかけて決めてください。非公開メンバ変数にアクセスする必要がないのにメンバ関数にする必要はあまりないと思いますが、迷った時は使いやすい方、メンテナンスしやすい方を選ぶのが良いでしょう。

### オーバーロード

[オーバーロード](https://en.cppreference.com/w/cpp/language/overload_resolution)とは、同じ名前の関数でも仮引数の数や型が異なれば別の関数として扱うことのできる仕組みです。コンストラクタを複数定義したときもオーバーロードしています。何が区別され、何が区別されないかについて、厳密な条件はかなり複雑です。簡単に確認する方法は、実際に複数の同じ名前の関数やテンプレートを定義してみて、コンパイルエラーになるかどうかを見ることです。また、ある引数リストを与えたときに、どのシグネチャとマッチするのかも、試してみるのが一番早いと思います。避けられない場合を除き、オーバーロード関数をたくさん定義するのは良いこととはいえません。どのシグネチャが選ばれるか分かりづらいと可読性やメンテナンス性が落ちるのはいうまでもありません。複雑なものは分かりにくいのです。同じ名前にする意味があるのかどうかを自問自答してください。別名でも問題ないのなら別名にしてください。迷ったら別名にすべきです。

オーバーロードを使う典型的な例をいくつか挙げておきます:

1. コンストラクタ
2. メンバ関数の const 版と non-const 版
3. const lvalue 参照を受けとるコピー版と、rvalue 参照を受けとるムーヴ版
4. 異なる型を扱うが同じ操作を意味する関数、演算子

最後の例は、テンプレートを定義することで、オーバーロードされた複数の関数をまとめて自動生成することも多いと思います。

<a name="operator-overload"></a>
### 演算子オーバーロード

演算子オーバーロードとは、クラス毎に、演算子の実装を自由に定義できる機能です。演算子といってもたくさんあるので、用途に応じて独自の定義をする演算子は限られるでしょう。代表的なものを挙げておきます。

- 比較演算子 `bool operator==(const T&) const`, `bool operator!=(const T&) const`, `bool operator<(const T&) const`, `bool opeator>(const T&) const`, `bool opeator<=(const T&)`, `bool operator>=(const T&) const`
  - オブジェクトの一致性や順序性を表すのに使えます。
  - 最近のコンテナやアルゴリズムは、比較のための関数オブジェクトを受けつけることが多いので、必ずしもクラスの側に比較演算子を実装する必要はないことが多いです。
  - 一致性を意味する `==` と `!=` は、同時に定義し、一貫性が損われないようにしましょう。
  - 順序性 `<` `<=` `>` `>=` についても同様です。
- 代入演算子 `T& operator=(const T&)`, `T& operator=(T&&)`
  - オブジェクトのコピーやムーヴを実装したいときに定義します。
  - コピーコンストラクタやムーヴコンストラクタと一緒に定義されることが多いです。copy のみ、move のみのサポートをするケースもあります。
- ファンクタ `operator()(...)`
  - 関数オブジェクトとして振る舞うときの挙動を定義できます。引数や返り値の型は自由に決められます。

    関数オブジェクトとして振る舞うことを求められているとき以外は、きちんと名前を付けて通常のメンバ関数として呼ぶべきです。
- 添字演算子 `T& operator[](size_t)`、`const T& operator[](size_t) const`
  - 要素へのアクセスを実現するために定義します。`std::vector` や `std::string` が持っていますね。
- その他、たくさんあるので必要に応じて自分で調べてください。

オーバーロードなので、引数の異なる型ごとに演算子を定義すればもちろん挙動を変えることができます。ただし、実体が選ばれる条件が複雑になってしまい、間違えやすくなるようならオーバーロードは諦め、異なる名前をつけたり、異なるクラスに分離したりするなどしてメンテナンス性を損わないようにしましょう。

<a name="inheritance"></a>
### 継承の使いどころ

継承は、本当にすべきかどうかをよく考えてからにしてください。`is-a` と `has-a` の違いについて調べてください。昨今の C++ で継承を利用すべきケースは初心者の方が思っているよりもかなり限られます。不用意な継承の使用は、著しくメンテナンス性の悪いコードへの第一歩となります。

仕方なく継承を使うケースとして、多態 (polymorphism) が挙げられます。多態とは、ここでは、基底クラス型のポインタに、複数の派生クラス型のオブジェクトポインタを格納し、同じメンバ関数呼び出しでもオブジェクトの実際の型によって異なる挙動をさせる使い方を指します。多態させるメンバ関数と、デストラクタは、 virtual メンバ関数にすることを忘れないでください。C 言語だと `union` を使って行うような処理ですが、C 言語の場合は自分で型を判定できる要素を用意しておいて自分で条件分岐して挙動の変化を実現します。Virtual メンバ関数を定義してしまうと、オブジェクトは vtable という構造を持ち、関数呼出時に型によって処理を分岐する必要が生じるため、オーバーヘッドが発生しますので注意が必要です。逆に、virtual キーワードを指定しない場合、あるコードにおいて用いられる型は静的に(コンパイル時に)決まってしまうため、同じ名前のメンバ関数だけれど、オブジェクトの実際の型によって中身が異なるものを実行するという目的は達成できないでしょう。以下の例に挙動の違いを示します。

```c++
#include <cstdio>
#include <memory>

struct A
{
    virtual void f1() { :: puts("A::f1"); }
    void f2() { ::puts("A::f2"); }
    virtual ~A() noexcept {}
};

struct B : A
{
    void f1() { ::puts("B::f1"); }
    void f2() { ::puts("B::f2"); }
    void f3() { ::puts("B::f3"); }
    ~B() noexcept {}
};

int main()
{
    A* p(new B());
    p->f1();
    p->f2();
    //p->f3();
    dynamic_cast<B*>(p)->f3();
    ((B*)p)->f3();
}
```
`A*` のポインタであったとしても、`f1()` は virtual メンバ関数なので、多態に相応しい挙動をし、`B::f1()` が呼ばれます。しかし、virutal ではない `f2()` は、`A*` の型だけ見てコンパイル時に呼ぶ関数を決定しますので、`A::f2()` が呼ばれます。`f3()` に至っては `A` で定義されてないのでキャストなしでは呼ぶことすらできません。それが `B` のオブジェクトであることを確信できる場合のみキャストを使えますが、それはすなわち、`p` が指しているオブジェクトの型が `B` であるかどうかを判別する明示的な条件分岐を必要とするわけです。

```c++
// 悪い例
struct A
{
  ~A() {}  // non-virtual destructor
};

struct B : A
{
   int *p;
   B() : p(new int(0)) {}
   ~B() { delete p; }
};

int main()
{
    A *a = new B();
    delete a;  // ~A() が呼ばれ、~B() は呼ばれないので、メモリリーク
}
```

多態に限らず、継承するときに気をつけなければいけないこととして、派生クラスでリソースの開放処理を行う場合、デストラクタは virtual メンバ関数にしておかなければならないことです。この例では、`~A()` に virtual を指定しておけば  `A*` 型の変数から `B` 型のオブジェクトを指していたとしても、ポインタの型 (`A`) ではなく、実体の型 (`B`) のデストラクタを呼んでくれます。`~B()` だけに virtual を指定しても `~A()` は自動的には virtual にならないのがややこしいところです。

Mix-in は、virtual メンバを使わずに、派生型でメンバ変数を新たに定義せず、メンバ関数だけを増やす手法です。Mix-in は vtable を必要とするオブジェクトが持つデメリットの影響を受けないので気軽に使えますが、使いどころは限られます。

異なる型だけれど、同一のシグネチャを持つメンバ関数を持つことを保証させる機能をインターフェースといいます。C++ で継承を使ってインターフェースを実現するには virtual クラスを用いた多態をすることになります。インターフェース機能を使うなら、継承を使うよりは、テンプレートを使う方が良いかも知れません。ただし、テンプレートは静的に型を解決するので、使う型の数だけコードが増えるというデメリットもあります。

C++17 では `std::variant` という型が導入されました。これは C 言語の `union` と同じ仕組みを、C++ の型に合わせて実現したもものです。Copyable class だけでなくて、Movable class のオブジェクトも格納できますので、使いどころはありそうです。ただ、オブジェクトの型によって適切な処理を実行するコードは自分で書かないといけない点が、継承を使った多態とは違うところです。

<a name="private-declaration"></a>
### private 宣言について

メンバ変数やメンバ関数を private にすることによって、メンバ関数以外からアクセスできないようにすることをカプセル化と呼んだりします。余計なものを見せないことで、オブジェクトの外と内の境界を、出来るだけ単純なものにし、メンテナンス性を担保する目的があります。逆にいえば、むやみに private 化するのもまた意味がないということです。

```c++
struct A
{
private:
    int i_;
public:
    void set(int i) { i_ = i; }
    int get() const { return i_; }
};
```

 こんなコードを書くくらいなら、素直に `i_` を public にして直接アクセスすれば良いですよね。入力をチェックする必要があるだとか、必ず加工してから出力するなどの理由があれば、private に留める方が良い場合もあると思います。

<a name="memory"></a>
## メモリ

<a name="new-and-delete"></a>
### new と delete

C 言語だとヒープメモリは `malloc` 関数を使って確保し、`free` 関数を使って解放するのが一般的です。`malloc`/`free` 関数は C++ でも使えますが、それとは別に `new` 演算子と `delete` 演算子が用意されています。`new`/`delete` はヒープオブジェクトの確保と開放を行う操作で、ヒープメモリの確保解放だけではなくコンストラクタ/デストラクタ呼び出しもするという点が `malloc`/`free` とは異なります。
最も大事な点は、`new` や `delete` を素で呼んではいけないことです。要するに以下のようなコードを書いてはいけません。

```c++
A *p = new A();
delete p;
```

自分で確保したメモリ断片を管理するための専用のラッパークラスを定義すべきです。もしくは別途説明するスマートポインタを使うことが推奨されます。なぜならそうしないと我々はいとも簡単にメモリリークするバグを埋めこんでしまうからです。
C 言語では注意深くコードを書かないとすぐにメモリリークしますが、C++ では、上記の注意を守っていれば、まずリークしません。後述する RAII がメモリを含むリソースのリークから我々を守ってくれるからです。

<a name="raii"></a>
### RAII によるリソースリークの防止

[RAII](https://en.cppreference.com/w/cpp/language/raii) とは、*Resource Acquisition Is Initialization* の略で、リソースの寿命をオブジェクトの寿命に合わせることで、リソースリークをなくすことができる手法です。具体的には、リソースの確保をコンストラクタで行い、開放をデストラクタ内で行います。例外が飛んでも対応するスコープを抜けて寿命が尽きたオブジェクトのデストラクタは必ず呼ばれるので、開放し忘れることがないという仕組みです。リソースとして、メモリだけでなく、ロック、ファイルディスクリプタ、ネットワークコネクション、などなど様々なものを対象に出来ます。
C++11 でのムーヴセマンティクスの導入に伴い、オブジェクトの移譲がやりやすくなったので、ますます RAII が気軽に使えるようになったと言えます。
長時間動作するサーバープロセスなどのプログラムでは特に、プログラムが使う全てのリソースに対して RAII を使うことを強くオススメします。必要があれば自分でラッパークラスを作ってください。これで、我々はリソースリークしないプログラムを手にいれることができます。
デストラクタ自身は例外を投げられないので、リソース開放処理中に発生した例外を検知、処理したい場合は、リソース開放を実行するメンバ関数(`close()` など) を用意して、`try-catch` 節内で明示的に呼び出す必要があります。そのようにクラスを設計したとしても、`close()` を忘れたときのために、デストラクタでも `close()` を呼ぶようにして、万全を期すアプローチが有効でしょう。もちろん `close()` はべき等になるように設計するか、フラグ等を用いて一度しか呼ばれないようにしておく必要はあります。

```c++
struct A
{
    bool closed_;
    Resource resource_;
    A() : closed_(false), resourece(open_resource()) {}
    ~A() noexcept try {
        close();
    } catch (...)
    }
    void close() {
        if (closed_) return;
        close_resource(resource_);
        closed_ = true;
    }
};
```



<a name="smart-pointers"></a>
### スマートポインタ

C++11 以降でスマートポインタが使えます。`std::unique_ptr` と `std::shared_ptr` です。これらはヒープオブジェクトをラップし、RAII の恩恵を受けられる最も基本的なクラスです。簡単に説明すると、`new` 演算子で確保されたオブジェクトをスマートポインタに入れて管理すると、スマートポインタの寿命が来たときに、自動的にデストラクタが呼ばれ、その中で `delete` が呼ばれて指していたヒープオブジェクトが開放されるのです。

```c++
{
    std::unique_ptr<A> p(new A());
}  // p の寿命。p が管理していた A 型のヒープオブジェクトは p のデストラクタによって自動的に delete される。
```

スマートポインタは、変数の寿命とヒープオブジェクトの開放タイミングを一対一対応させ、開放忘れを防いでくれます。我々がコードを書くときに、特に何も注意しなくても、関数内ローカル変数の寿命はブロックの終わりで尽きることが多いですから、注意深く `delete` を実行するコードを手動で書くのに比べて圧倒的に安全です。

`std::unique_ptr` と `std::shared_ptr` は、オブジェクトをひとつの変数で占有するか、複数の変数で共有するかよって使い分けますが、`std::shared_ptr` を使う場面は多くないでしょう。ありがたいことに、生ポインタに比べて `std::unique_ptr` を使うために追加で必要なオーバーヘッドはありません。64bit アーキテクチャの場合、`sizeof(std::unique_ptr<A>)` は  64bit です。追加のコストなしに使えるので、ほとんどの場面でヒープオブジェクトの管理のため `std::unique_ptr` を使うべきです。一方、`std::shared_ptr` はオーバーヘッドなしとはいかず、コントロールブロックをヒープオブジェクト毎に持ち、それへのポインタを追加で持つため、`sizeof(std::shared_ptr<A>)` は大抵 128bit です。

`std::unique_ptr`  を使っていたとして、一時的に関数などに渡して使う場合は `std::unique_ptr` それ自身の参照渡しもしくは中身のポインタを生で渡せば良いですし、ムーヴを使うことで他の変数や参照渡しされた引数などに管理を移譲することもできます。所有と借用の概念については別途説明しますが、`std::unique_ptr` 自身もしくはそれを所有しているオブジェクトが所有者で、生ポインタや参照を持っているオブジェクトは借用者だと考えれば、オブジェクトの開放に責任を負っているのは所有者で、所有者の寿命が一番長くなるように気をつかえば、問題にはなりません。

生ポインタを使うことは確かに危険を伴いますが、利便性と安全性のトレードオフをうまく取るのが良い選択です。オブジェクトの寿命を意識し、ポインタの dereference (間接参照によるアクセス) を使うのはオブジェクトが生きている間だけ、という鉄則を守ってください。プログラムの中で、そのような特別なケアをしなければならないオブジェクトはごく一部なので、気をつかうのもその周辺のコードだけで済むのは有り難いことです。問答無用で全部のヒープメモリの寿命を手動管理させられる C の世界に比べれば天国でしょう。

`std::shared_ptr` の使いどころがあるとすれば、誰が一番寿命が長いのかが自明ではないようなときで、かつリファレンスカウント方式の garbage collection を採用したいケースに限られるでしょう。たとえばマルチスレッドプログラムで、ふたつのスレッドが同一オブジェクトを `std::shared_ptr` で指していて、どちらかが先に寿命を迎えるか分からないようなときです。

ここまで説明しておいてなんですが、同一型の複数のオブジェクトをまとめて管理したいときは、STL のコンテナライブラリが役に立ちます。多くの場合、`std::unique_ptr` で管理しなくても、コンテナを使えば事足ります。コンテナは要素を格納する領域をヒープメモリから確保し、寿命が来たら デストラクタで必要な開放処理を行います。もちろん RAII に従っています。

### 動的確保した配列よりも std::vector

配列の動的確保をするのにも `new` 演算子を使えますが、ほとんどの場合代わりに `std::vector` を使うべきです。
たとえば `int` 型の配列を動的に確保して使うことを考えてみましょう。`new` を使う場合は、
```c++
{
    std::unique_ptr<int[]> v(new int[10]);
    // v を使う。サイズが 10 であることは別途覚えておく必要がある。
}   // std::unique_ptr<int[]> のデストラクタが delete[] を呼ぶ。
```
と書きます。`std::unique_ptr` を使わないのであれば別途 RAII のためのラッパークラスを定義すべきです。そうしないとメモリリークしやすくなります。ここでの `new` 演算子は先頭要素へのポインタを返すため、サイズ情報は自分で管理する必要があります。実質的には連続メモリ断片をひとつヒープ領域から確保しただけですから、コンパイル時に要素数やサイズが決まる配列とは違います。各要素はデフォルトコンストラクタで初期化されます(`int` の場合は `0` で初期化されます)。デフォルトコンストラクタを持たない型の配列はこの方法では確保できません。
`std::vector` を使う場合は、
```c++
{
    std::vector<int> v(10);  // 内部的に連続するヒープメモリを確保
    // v を使う。v.size() でサイズも分かる。
} // std::vector<int> のデストラクタがヒープメモリを開放
```
となります。デフォルトコンストラクタを持たない型でも、

```c++
{
    std::vector<A> v(10, A(arg0, arg1));
}
```
と書けば初期化できます。ただ、このコンストラクタを使った場合は `A` はコピーされてしまうので算術型以外の要素で使うのはあまりオススメしません。直接任意のコンストラクタを呼んで初期化したい場合は、
```c++
{
    std::vector<A> v;
    v.reserve(10);
    for (size_t i = 0; i < 10; i++) {
        v.emplace_back(arg0, arg1);
    }
}
```
とすれば、ヒープメモリの確保は 1 回だけに抑えて、要素毎にコンストラクタを呼べます。他にも `std::vector` は便利なメンバ関数を色々と供えていますので、是非使ってください。

`std::vector` を使うデメリットがあるとすれば、`std::vector` は要素を格納するヒープメモリ以外に見かけ上のサイズと実サイズの 2 つのデータを保持しているため、同一サイズの配列を大量に作るときは、それらがメモリ容量のオーバーヘッドになるかも知れないことでしょうか。一次元配列に関しては無視できる程度だと思います。

二次元配列が作りたいなら、次のようにします。
```c++
size_t size0 = 10, size1 = 100;
std::vector<std::vector<int> > vv(size0);
for (size_t i = 0; i < size0; i++) {
    vv[i].resize(size1);
}
```
メモリ確保が面倒ですね。`new` を使う方法はさらに面倒なので省略します。次元が増えていくと、`std::vector` を使ったとしてもどんどん面倒になるので、サイズ固定の多次元配列を動的に確保したいなら、ひとつの `std::vector` の一次元配列を多次元配列に見立て、アクセス用のメンバ関数を用意した方が良さそうです。
```c++
class TwoDimensionalIntArray
{
    const size_t s0_, s1_;
    std::vector<int> v_;
    TwoDimensionalIntArray(size_t s0, size_t s1) : s0_(s0), s1_(s1), v_(s0 * s1) {}
    int get(size_t i, size_t j) const {
        assert(i < s0_); assert(j < s1_);
        return v_[i * s1 + j];
    }
    void set(size_t i, size_t j, int value) {
        assert(i < s0_); assert(j < s1_);
        v_[i * s1 + j] = value;
    }
};
```
このようなクラスは STL にはないですが、そこらのライブラリに用意されていますので、それを使うのも手です。

<a name="placement-new"></a>

### Placement new

特殊な用途なので、ここに書くか迷ったのですが、 `malloc` が通常保証する 8 bytes よりも大きな単位 (例えば 64B や 512B や 4KiB など) で alignment を揃えてヒープオブジェクトを確保したい場合があります。これを可能にするのは `posix_memalign()` や `mmap()` などの特殊な libc 関数やシステムコールです。それらを使ってヒープメモリを確保したのはいいですが、C++ オブジェクトとして振る舞って欲しい、すなわち、コンストラクタとデストラクタを呼びたいときはどうしたら良いでしょうか。そのような場合には、ラッパークラスを作って、そのコンストラクタ内でメモリを確保して placement new 演算子を呼び、ラッパークラスのデストラクタ内で元のクラスのデストラクタを明示的に呼んだ後に `free()` や `munmap()` を呼んでメモリを開放すれば良いです。

```c++
#include <cstdlib>
#include <new>

struct A {
    A() {...}
    ~A() {...}
};

struct B {
    A *a;
    B() : a(alloc_and_cstr()) {
    }
    ~B() {
        a->~A();
        ::free(a);
    }
    static A* alloc_and_cstr() {
        void *p;
        if (::posix_memalign(&p, ALIGNMENT, SIZE) != 0) {
            throw std::bad_alloc();
        }
        try {
            a = new(p) A;
        } catch (...) {
            ::free(p);
            throw;
        }
        return a;
    }
};
```
`new(p) A` が placement new 演算子を使って初期化する操作です。Try-catch 節は `A` のコンストラクタが例外を投げるケースをカバーしています。注目しているコード上では例外が投げられる可能性があることが明示的には見えないのがこの問題を見つけにくくしていると思います。ただ、今回のような例はむしろ例外的で、通常はメンバ変数の初期化子内でメンバ変数のリソースを確保しますし、コンパイラがよろしくやってくれますので問題にはなりません。ただし、助かるのは適切なデストラクタを持っているメンバ変数であって、生ポインタを使う場合は自分でコードを書いてリークを回避するしかありませんのでご注意ください。

<a name="variables"></a>
## 変数

変数はデータを格納する箱と説明されることが多いです。ある型のデータを入れることを想定した連続メモリ領域のことを[オブジェクト](https://en.cppreference.com/w/cpp/language/object)と呼びます。変数はオブジェクトに名前をつけたものというのが、正確ではないかも知れませんが分かりやすい説明かと思います。オブジェクトには対応する型の具体的なデータ、すなわち値が格納されます。C++ における変数は値型変数、ポインタ型変数、参照型変数の 3 種類があります。値型変数は、対応した型の値が格納されます。算術型 (arithmetic type) の値 (int 型の 1 や float 型の 2.3 など) や、クラス型であればその具体的なインスタンスの値です。ポインタ型変数は、オブジェクトの位置を表わすメモリアドレスを格納します。メモリアドレスが格納される領域もオブジェクトとして扱います。つまり、ポインタ型変数にとっての「値」はメモリアドレスということになります。例えば `int **a;` は 「`int` オブジェクトを指しているポインタ型オブジェクト」を指しているポインタ型オブジェクトに `a` という名前がついていることになり、二段階の関節参照を意味しています。参照型変数は既に存在するオブジェクトの別名という扱いです。型についての詳しい分類が[ここ](https://en.cppreference.com/w/cpp/language/type)に書いてあります。その説明によればオブジェクト型はポインタ型を含みますが、参照型は含みません。関数の参照型引数やクラスの参照型メンバ変数はアドレスを格納しますので、これらの場合はポインタと大体同じものだと思ってもらって構わないと思います。

プログラムから見える、オブジェクトが配置されるメモリ領域には、静的領域、スタック領域、ヒープ領域の 3 つがあります。グローバル変数やファイル内ローカル変数は静的領域に、関数内ローカル変数はスタック領域にデータが格納されます。関数呼び出しの度に、呼び出し側のローカル変数を保持したままにする必要があるので、スタックは伸びます。逆に、関数が返る度にそのローカル変数は寿命を迎えて不要になるのでスタックは縮みます。ヒープ領域にはオブジェクトを配置できますが、それを指して使うには、ポインタ型変数や参照型変数が必要になります、つまりグローバル変数やローカル変数から辿れるようになっていないと使えません。オブジェクトが配置される領域によって、スタックオブジェクト、ヒープオブジェクトなどと区別することがあります。

C++ を扱うならば、是非オブジェクトのメモリイメージを意識してもらいたいです。例えば、以下のようなクラス `A` を考えます。
```c++
struct A
{
    int i;
    int j;
};
```
`A` のインスタンスオブジェクトは、コンパイラやそのオプション次第で変わり得ますが、通常 4 + 4 = 8 bytes のデータを持つ連続メモリ断片となります。つまりコンパイル時に型のサイズ `sizeof(A) == 8` が決まります。それでは、以下の `B` はどうでしょうか。
```c++
struct B
{
    int i;
    int j;
    A *a;
};
```
`B` のインスタンスオブジェクトは 64bit アーキテクチャでは通常 4 + 4 + 8 = 16 bytes のデータを持つメモリ断片となります。つまり `sizeof(B) == 16` ということです。ポインタ型メンバ変数 `*a` が別のメモリ領域にある `A` 型オブジェクトを指し得ます。連続メモリ断片としては、`B` のインスタンスオブジェクトには `*a` が指す `A` 型オブジェクトのアドレスは含んでいても、値そのものは含まれないことに注意してください。ただ、文脈によっては、ポインタ型や参照型のメンバ変数が指しているオブジェクトも含めて広い意味でひとつの「オブジェクト」と考える場合もあります。

<a name="scope-and-lifetime"></a>
### スコープと寿命

[スコープ](https://en.cppreference.com/w/cpp/language/scope)とは、変数にアクセス可能なコード範囲のことです。スコープにはいくつか種類がありますが、代表的なものは、ブロックスコープ、関数スコープ、関数パラメータスコープ、クラススコープなどです。大雑把な理解の仕方として `{}` で囲まれた領域はスコープです。変数の[寿命](https://en.cppreference.com/w/cpp/language/lifetime)は変数が宣言されてから、対応するスコープの終わりまでです。なぜスコープや寿命を意識する必要があるといえば、それらの終わりで変数に格納されているオブジェクトのデストラクタが暗黙的に呼ばれるからです。我々の思い通りにリソースをコントロールするために、我々はリソースがいつ開放されるかについて知っておく必要があります。昔の C と違って、C++ ではブロックや関数の途中でも変数が宣言できますので、必要なときに宣言することで、スコープを可能な限り小さくすることができますし、メンテナンスの観点からもそうすべきです。

注意点として、`new` で確保したヒープオブジェクトのアドレスを生ポインタに格納し、その変数が寿命を迎えると、それが指していたヒープオブジェクトはリークします。ヒープオブジェクトに元々寿命はないのです。オブジェクトのリークとは、そのオブジェクトをもはや誰も使わないのに、期待を裏切って開放されずにメモリを占有し続けてしまうことをいいます。これは明らかにバグですね。何故リークしてしまうのかといえば、生ポインタにはデストラクタなどなく、それが指しているヒープオブジェクトを開放する責任がないからです。明示的にヒープオブジェクトを所有させ、寿命と共に `delete` させたいときはスマートポインタを使いましょう。

関数が値返しであるならば、そのオブジェクトはたとえ関数内ローカル変数(関数内で定義され、関数の終わりでスコープが終わり、本来であればデストラクタが呼ばれる)だったとしても、関数の返り値を受けとる変数内にコピーやムーヴされることがあります。C++ では条件にもよりますが最適化によって コピーやムーヴが省略されます。つまり、格納される変数は関数内のものから呼出側のものへと変わりますが実質的にオブジェクトの寿命が延びるわけです。C++17 ではこの返り値関連の最適化を含む [copy elision](https://en.cppreference.com/w/cpp/language/copy_elision) が義務化されました。

関数によって値返ししたり、コンストラクタを直接呼び出して作ったオブジェクトなどは一時オブジェクトと呼ばれますが、一時オブジェクトの寿命はその使われ方によって変わります。通常、一時オブジェクトの寿命はそれを含む文が終わるまでですが、const lvalue reference または rvalue reference で受けたときは、その変数のスコープまで寿命が延びます。ここで注目している一時オブジェクトはあくまでスタックオブジェクトで、ヒープオブジェクトではないことに注意してください。

<a name="variable-initialization"></a>

### 初期化

オブジェクトの[初期化](https://en.cppreference.com/w/cpp/language/initialization)についても気をつける点があります。原則として変数宣言や領域確保から初期化までのタイムラグはゼロか、ごく短かくなるようにしましょう。算術型では C 言語と同じように、`int i;` のように初期化なしで宣言した場合は内容が不定になります。ヒープオブジェクトの場合も同様で、`int* i = new int;` と書くと不定となります。グローバル変数や static 変数など静的領域に確保されるものは `static int i;` などと宣言すると[ゼロに初期化](https://en.cppreference.com/w/cpp/language/zero_initialization)されます。算術型をメンバ変数に持つクラスでも、コンストラクタの初期化子を使って初期化しないと不定になります。たとえば `struct A { int i; };` における `i` は `A` の初期化後も不定です。そのような細かい知識を知らなくても安全なプログラムを書くために、明示的な初期化を心がけることをオススメします。明示的な初期化とは以下のような操作です:

1. 算術型は初期値を明示的に与えて宣言/確保する。例: `int i = 0;`、`int* i = new int(0);`
2. 算術型をメンバ変数に持つクラスは、コンストラクタの初期化子で明示的に値を与える。例: `struct A { int i; A() : int(0) {} };`
3. その他、メンバ変数の初期化が保証されていない型を使う場合は、与えられた手段で宣言/確保後出来るだけ速やかに初期化する。必要があればそれを自動で行うラッパークラスを作る。

明示的に初期値を与えたくない場合があるとすれば、それはコピーや計算結果の代入など他の手段で初期化する予定で、最初に `0` などを設定するのは無駄であり、性能に影響する、というケースでしょうか。分かって使う分にはまったく問題ありませんが、メンテナンス性の上で、不定な値にアクセスするリスクがあるという認識は持っておいてください。また、他人の書いた変数宣言やクラス定義のメンバ変数とコンストラクタを見て、宣言/確保時に不定なのか不定でないのかを判断するクセがつくと良いと思います。

C++11 からのユーザー定義型オブジェクトの初期化に関する注意点としては、`A a;` のような何も指定しない初期化 (default initialization)、`()` による初期化 (direct initialization)、 `=` による初期化 (copy initialization) に加えて、`{}` による初期化 (list initialization) も使えるようになったことです。Direct initialization はコンストラクタに引数を与えて初期化するごく普通の初期化方法です。Copy initialization はコピーコンストラクタやムーヴコンストラクタを使う初期化です。List initialization はコンテナ型のオブジェクトにおいて `std::initialization_list<T>` で受けるコンストラクタを用意しておいて、同じ型の要素を並べて初期化に用いるのがメインの使い方のようです。

<a name="having-and-borrowing"></a>
### 所有と借用

C++ で明確に定義されているわけではないと思いますが、プログラムを設計実装する上で重要な概念だと思うので、ここで、所有と借用について説明しておきます。

所有とは、所有者が、所有される対象リソースの開放に責任を持っていることを指します。所有者の関係として考えられるのは、変数とそれが格納/参照しているオブジェクトだったり、オブジェクトとそれが管理しているメンバ変数などのリソースだったりします。あるリソースがあったとき、それを開放できるのはひとりだけですから、明示的にせよ潜在的にせよ、所有者は原則ひとりだけということになります。C++ においては、RAII を使ってコンストラクタでリソースを確保し、デストラクタで開放するクラスを設計した場合、そのインスタンスオブジェクトは、まさに当該リソースを所有していると言えるでしょう。値型変数は、寿命が来たときにデストラクタを呼ぶことから、格納しているオブジェクトを所有していると言えるでしょう。自分でリソース確保したわけでなくても、他のオブジェクトからムーヴされたリソースがあって、それを自分のデストラクタで開放する必要がある場合、そのオブジェクトは、当該リソースを所有していると言えるでしょう。また、オブジェクトはそのメンバ変数(が格納しているオブジェクト)を所有しているといえるでしょう。*has-a* 関係と言われるわけですし、デストラクタでメンバ変数のデストラクタが呼ばれるわけですから、開放に責任を持っているわけです。さらに、生ポインタ(生のポインタ型変数)や参照(参照型変数)が指しているヒープオブジェクトについて考えてみましょう。ポインタや参照はあくまでオブジェクトを指しているだけですし、複数のポインタや参照がひとつのオブジェクトを指していることもあります。しかし、誰かがオブジェクトを開放しなければ、それはリークしてしまうわけなので、期待されるべきこととして、誰かが開放に責任を持っていることになり、潜在的であったとしても所有者がひとりいると考えることができます。

借用とは、自分は所有者ではないけれど、対象のオブジェクトやリソースを指していて使う行為を指します。C++ においては、ポインタ型変数や参照型変数とそれが指しているオブジェクトが、多くの場合、借用関係にあたると考えられます。先程の例で、複数のポインタがひとつのヒープオブジェクトを指しているとき、ひとりは所有者で、残りは借用者というわけです。

RAII パターンは、リソースの寿命を変数の寿命と合わせることで、所有者であることを明確にする役割があると思います。ある変数が、あるリソースを唯一指している状況にも関わらず、その開放に責任を持っているという自覚なしにコードを書けば、リソースリークしやすくなってしまいます。また、借用者である変数が、その所有者よりも寿命が長いとき、その指している先が不正なメモリ領域である状態が発生します (dangling pointer/reference)。それにアクセスしてしまうとセグメンテーションフォールトなど不正な動作をします。すなわちバグです。

バグの少ないコードを書くために、所有者と借用者の区別をしっかりとつけて、所有者はリソースを責任をもって開放すること、所有者よりも借用者の寿命が長くならないように心がけましょう。Rust などではそれを言語機能としてプログラマに強力な制約を課してくるようですが、C++ はあくまでそれを助ける機能が存在するという印象です。自由には責任が伴う、ということですね :)

<a name="exception"></a>
## 例外

<a name="exception-introduction"></a>
### 例外の概要

C++ の例外は、大域脱出の手段です。例外オブジェクトを作成し、`throw` 文で投げます。`try` 節の中で投げられた例外オブジェクトは呼び出し側を辿ってスタックを巻き戻し、最初に `catch` 節(例外ハンドラ)が定義されているところまで処理を飛ばします。ただし、`throw` 文を投げる時点で生きていたスタックオブジェクトで、例外ハンドラに到達するまでの間にスコープを抜けて寿命を終えたものを対象としたデストラクタの呼び出しだけは必ず実行されます。

スレッドの一番上の呼び出し側コード(メインスレッドの場合は main 関数)に至っても例外ハンドラが定義されていない、すなわちその例外を投げたコードはどの `try` 節にも含まれていなかった場合、プログラムは強制終了します。マルチスレッドプログラムの場合もひとつのスレッドで例外をキャッチしそびれるとプロセスまるごと死にます。STL も例外を飛ばす可能性がありますから、例外は常に飛ぶ可能性があると考えて、コードを書くようにしましょう。つまり、一番上の呼び出しコード (main 関数やスレッドの起動時に実行する関数) で例外ハンドラを定義するのを忘れないようにしましょう。STL で投げられる例外や、お行儀の良い大抵の例外型は `std::exception` を継承していますので、それで受ければほぼ全ての例外がキャッチできます。例外を飛ばさないのは、C 言語互換の関数と、`noexcept` 指定で例外を飛ばさないことが明示されている関数だけで、それ以外は全部飛ばす可能性があるものとして扱いましょう。

問題点として、例外の仕組みの実現にはコストがかかります。バイナリサイズが増えるし、遅いです。その原因は大域脱出の仕組みだったり、途中経路のデストラクタ呼び出しのための処理だったりするようです。

例外がどこで発生したのかを知る方法はデフォルトでは用意されていません。自分で例外オブジェクトに問題を解析するために必要な情報を付加する必要があります。たとえばデバッグが目的ならスタックトレース情報などが欲しくなるでしょう。標準ライブラリではありませんが、例えば、[cybozulib](https://github.com/herumi/cybozulib/) の `cybozu::Exception` は `throw` 時のスタックトレースを例外オブジェクト内に保持し、例外ハンドラでそれを参照できる機能を持っています。

<a name="exception-in-destructor"></a>
### デストラクタ内で発生した例外処理

例外を投げている途中に例外が投げられたらどうなるでしょうか？そのようなことが起こり得るのは、オブジェクトのデストラクタ内の処理です。例外が投げられても、スコープを抜けたオブジェクトのデストラクタは必ず実行されるのでした。例外が飛んでいる最中のデストラクタ処理で、デストラクタの外に新たな例外が投げられることが分かったときにプログラムは強制終了されます。逆に言えば、デストラクタ内で例外が発生しても、例外ハンドラをデストラクタ内に定義しておいて、例外処理すれば、プログラムは続行できます。

このような理由から、デストラクタ実行中に発生した例外の処理はほぼ握り潰さざるを得ませんが、それをどう扱うかはプログラム設計における選択になります。敢えてログを吐くか(`~A()`)、潔くプロセスを自分で殺すか(`~B()`)、無言で握り潰すか(`~C()`)。握り潰すとは例外をキャッチしておいて何もしないことです。

```c++
~A() noexcept {
    try {
        // try to deallocate resources...
    } catch (std::exception& e) {
        try {
            // try to put logs.
        } catch (...) {
            // do nothing
        }
    }
}

~B() noexcept {
    try {
        // try to deallocate resources...
    } catch (...) {
        ::exit(1);
    }
}

~C() noexcept {
    try {
        // try to deallocate resources...
    } catch (...) {
        // do nothing
    }
}
```

<a name="exception-and-return-value"></a>
### 例外と返り値エラーの使い分け

例外は便利ですが、重たいというデメリットもあるため、使いどころには注意した方が良いでしょう。発生頻度の高く、例外処理が性能に影響を及ぼし得るエラーについては、例外を使わずに返り値や参照引数でエラー情報を呼び出し側に伝え、エラー処理を行う方が良いでしょう。

C++ でプログラムを書き、STL のコンテナなどを使う時点で、`std::bad_alloc()` が投げられる可能性は常にあります。しかし、`std::bad_alloc()` が投げられたらまともにプログラムを動かし続けることは難しいと思います。そういう意味では、C++ は C よりもメモリにシビアな環境で動かすのは難しいのかも知れません。そのような環境を前提に C++ でプログラムを開発する場合は、例外や STL 等を使わないなどの特殊な使い方をする場合があるかも知れませんが、本ドキュメントで対象としている C++ の便利さを享受できなくなるのが辛いところです。

<a name="exception-spec"></a>
### 例外仕様

C++ の関数には、例外の種類を列挙させ、それ以外は投げられないことを示すインターフェースがあり、例外仕様と呼ばれていたそうです。具体的には `void f() throw(std::runtime_error);` といったものです。しかし、C++11 で例外仕様は非推奨になり、C++17 では削除されました。どうやら多くのコンパイラがこれを真面目に実装せず、単に無視されるだけだったようです。代わりに C++11 では `noexcept` キーワードが導入されました。これは、例外が投げられるのを許可するかしないかだけを指定するより単純なものです。`noexcept` を指定した場合は例外が投げられるのを許可せず、実際に投げられたら、呼出側に例外ハンドラが定義されていたとしても、即座にプログラムは強制終了されます。`noexept` を指定しない場合は、例外は投げられ得るものと見做されます。この情報は例外処理の最適化に使われるようです。

デフォルトのデストラクタが `noexcept` かどうかは[ここ](https://en.cppreference.com/w/cpp/language/destructor)に書いてあるように、条件によって決まるようです。自分で定義したデストラクタには `noexcept` を付けておき、例外を漏らさないようにするのが無難でしょう。

<a name="pointer-reference"></a>
## ポインタと参照

改めて説明しますが、ポインタ(ポインタ型変数)とは、ヒープオブジェクトやスタックオブジェクトのメモリ上の位置、すなわちアドレスをデータとして格納する変数です。ポインタは C 言語でも使いますし、解説もたくさんありますので、これ以上はここで説明しません。
参照は、実質的にはポインタです。しかし、C++ に慣れた人はポインタよりも参照を多用します。

<a name="reference"></a>
### 参照の価値

参照型変数(参照)の格納する値はポインタ型変数(ポインタ)と同じメモリアドレスで、あるオブジェクトを指しているだけですが、ポインタと違って、値型変数と同様の操作ができます。

`A` という型があったとします。

```c++
A a;  // normal variable
A& ref = a;  // reference variable
A* ptr = &a;  // pointer variable

ref.func();
ptr->func();

A* ptr2 = &ref;  // アドレスも取れます

// ref = nullptr; // 不可能
ptr = nullptr;
```

参照 `ref` は `.` 演算子でメンバにアクセスできますが、ポインタ `ptr` は、`->` でアクセスする必要があります。もちろん `ptr` が実在するオブジェクトを指していれば `(*ptr).func();` としてアクセスできますが。参照は、値型変数と同様に `&` でアドレスも取れます。参照は、その宣言時に必ず初期化を必要とし、実在するオブジェクトを右辺に必要とします。つまり、参照は常に必ずあるオブジェクトを指しています。ポインタは宣言と初期化を分離できますし、`nullptr` を格納できる点が異なります。そうです、参照は `nullptr` を保持できません。つまり、どのオブジェクトも指していない、という状態を表現できません。表現力という点において参照はポインタに劣るのです。だがそれが良いのです。別の言い方をすると、参照は、dereference (参照先のオブジェクトにアクセスする操作) が保証されたポインタであるとも言えます。

参照の寿命が、それが指しているオブジェクトの寿命と同じになるとは限りません。オブジェクトの寿命が参照より先に来てしまうことはあり得ます。そのような状況下で参照にアクセスすると、不定な動作を引き起こすでしょう。
```c++
A& f()
{
    A a;
    return a;
}
```
このコードはコンパイルできますが、明らかに変数 `a` の寿命は `f()` が完了した時点で尽きています。それなのに、`a` の参照を返してしまっているので、明らかに返り値は正しくない(`a` のデストラクタが呼ばれた後の、他の用途に再利用されたかも知れない)領域を指しており、バグです。ポインタでも同様のことが言えます。

### コピーセマンティクス

一般に、オブジェクトがコピー可能 (Copyable) であるときは、コピーコンストラクタとコピー代入演算子が定義されていて、それらの挙動はコピーであることが期待されています。以下の `C` のようなクラスが典型的な Copyable class です。

```c++
struct C  // Copyable class example
{
    // Default constructor
    C() = default;
    // Copy constructor
    C(const C& rhs) : C() { copy(rhs); }
    // Copy assign operator
    C& operator=(const C& rhs) { copy(rhs); return *this; }
    void copy(const C& rhs) {
        // rhs の中身を *this にコピー
    }
    C(C&&) = delete;
    C& operator=(C&&) = delete;
};
```

コピーコンストラクタやコピー代入演算子は、引数と返り値が参照となっています。

Copyable class は以下のように使えます。

```c++
void f(const C& c)
{
    // c を参照する
}

void g(C& c)
{
    // c を参照したり、更新したりする
}

struct A
{
    C c;
    const C& ref() const { return c; }  // const lvalue reference を返す
    C& ref() { return c; }  // lvalue reference を返す
};

int main()
{
    C c0;
    C c1 = c0;  // copy constructor が呼ばれる
    C c2;
    c2 = c1;  // copy assign operator が呼ばれる
    f(c0);
    g(c1);
    A a;
    const C& c3 = a.ref();  // const 版が呼ばれる
    C& c4 = a.ref();  // non-const 版が呼ばれる
    C c5 = a.ref();  // const 版、copy constructor が呼ばれる
    c5 = a.ref(); // const 版、copy assign operator が呼ばれる
}
```

`A::ref()` はオーバーロードされていてふたつの実体があり、引数や返り値に応じて適切なものが呼ばれます。

<a name="move-semantics"></a>
### ムーヴセマンティクス

C++11 で、ムーヴセマンティクスが導入されました。ムーヴとは、移譲とか、中身の移動、という操作を指します。これを所有権の移動と捉えても良いかと思います。従来の参照は `T&` という形だけでしたが、これに、`T&&` という新たな形が追加されました。`T&` を lvalue reference、`T&&` を rvalue reference と呼びます。 詳しくは [ここ](https://en.cppreference.com/w/cpp/language/reference) を見てください。

lvalue とか rvalue というのは、expression (式) の分類です。全ての expression は lvalue, prvalue, xvalue のいずれかひとつに分類されます。l は left、r は right の略、prvalue は pure rvalue の略、xvalue は expiring value の略です。lvalue と xvalue をまとめて glvalue、prvalue と xvalue をまとめて rvalue と呼びます。ものすごく大雑把に分類すると、名前がついてるのが lvalue で名前がついてないのが rvalue です。例を挙げると、lvalue は変数や、(メンバ)関数などで、アドレスを取れます。rvalue は即値、関数呼び出し(の返り値)などで、アドレスを取れません。詳しくは [ここ](https://en.cppreference.com/w/cpp/language/value_category) を見てください。

例外はありますが、大雑把に言うと lvalue reference `T&` は lvalue を受けることができます。(代入したり、関数の引数で受けとったりすることです)。rvalue reference `T&&` は rvalue を受けることができます。lvalue reference は関数の引数や返り値で使うだけでなく、参照変数としても使います。rvalue reference は専ら関数の引数や返り値のみで使うことが多いです。

なぜムーヴセマンティクスは導入されたのでしょうか。コピーだけだと困る、ムーヴをコピーと区別しながらも同様のインターフェースで記述したい、というのがモチベーションです。ムーヴ可能 (Movable) であるときは、ムーヴコンストラクタとムーヴ代入演算子が定義されていて、それらの挙動はムーヴであることが期待されています。以下のようなクラス  `M` が典型的な Movable class です。

```c++
struct M  // Movable class example
{
    // Default constructor
    M() = default;
    // Move constructor
    M(M&& rhs) : M() { swap(rhs); }
    // Move assign operator
    M& operator=(M&& rhs) { swap(rhs); return *this; }
    void swap(M& rhs) {
        // *this と rhs の中身を入れ変える。
    }
    C(const C&) = delete;
    C& operator=(const C&) = delete;
};
```

もちろん、Copyable かつ Movable というクラスも作れます。ムーヴ操作を、コピーと同じ挙動として実装しても意味としては問題ありませんが、一般には、ムーヴ操作は、コピー操作よりも低コスト、高速であることが期待されます。C++11 以降の STL コンテナは必ずしも Copyable な class でなくても Movable な class であればそれを要素として典型的な使い方が出来るようになっています。

Movable class は Copyable class と出来るだけ同じような使い方ができて、しかしコンパイラが挙動を区別できるような仕組みになっています。

```c++
void f(M&& m)
{
    M m1 = std::move(m);  // move constructor が呼ばれる
}

struct A
{
    M m;
    const M& ref() const { return m; }  // const lvalue refernece を返す
    M&& ref() { return std::move(m); }  // rvalue reference を返す
    // M& ref() { return std::move(m); }  // M& を返すものと M&& を返すものはオーバーロードできない
}

int main()
{
    M m0;
    // M m1 = m0;  // copy constructor は定義されていないのでコンパイルエラー
    M m1 = std::move(m0);  // move constructor が呼ばれる
    M m2;
    m2 = std::move(m1);  // move assign operator が呼ばれる
    M&& m3 = std::move(m2);  // rvalue reference で xvalue を受ける
    f(std::move(m3));  // m3 は lvalue なので std::move() で xvalue にする必要がある
    A a0;
    M m4 = a0.ref();  // non-const 版、move constructor が呼ばれる
    M&& m5 = a0.ref();  // non-const 版が呼ばれる
    const M& m6 = a0.ref();  // non-const 版が呼ばれる
    const M& m7 = static_cast<const A&>(a0).ref();  // const 版が呼ばれる
    // M& m8 = a0.ref();  // rvalue は M& では受けられないのでコンパイルエラー
    const A a1;
    // M m7 = a1.ref();  // const 版、copy constructor を呼ぼうとするが、後者がないのでコンパイルエラー
    const M& m8 = a1.ref();  // const 版が呼ばれる
}
```

`std::move()` はただのキャストですが、lvalue を xvalue に変換するという点で意味を持ち、オーバーロードされた別の関数を選択させます。考えられる全ての組み合わせを挙げたわけではありませんが、我々が movable class を使う場合は「移動」をしたいのであって、通常はごく一部の組み合わせでしか使いません。

例えば、オーバーロードで複数の参照型と const が使われている場合に、不可解な挙動をするようにも見えます。const でない変数 `a0` において `ref()` を呼び出す場合、`const M&` で受けようとしても `A&&` を返す non-const 版が優先されてしまいます。const 版を呼ぶには `static_cast<const A&>` を使う必要があります。この例では敢えてオーバーロードさせてありますが、rvalue reference を返す関数を定義するときは、lvalue reference を返す関数とオーバーロードするのはやめて関数名を分けるのが懸命でしょう。


<a name="pointer-and-reference-usage"></a>
### ポインタと参照の使い分け

ひとことで言うと、ポインタは `nullptr` を格納でき、参照は必ずオブジェクトを指します。だから、関数の引数で `nullptr` であることを許容しないときは参照で受け、`nullptr` を渡すことを許し、それに意味を持たせる場合はポインタで受けるという使い分けをすると良いでしょう。参照で受ける方が制約が強く、上記のルールに従ってコードを書けば、参照で受ける場面が一般に多くなると思います。参照で受ける場合は、`const T&` か `T&` か `T&&` のどれで受けるか迷うかも知れません。その場合、以下のように使い分けると良いでしょう:
1. 関数内で対象オブジェクトを変更しない場合は `const T&`
2. 関数内で対象オブジェクトを変更して、後で呼び出し側がそれを使う場合は `T&`
3. 関数内で対象オブジェクトをムーヴして、後で呼び出し側がそれを使わない場合は `T&&`

`const T&&` も指定できますが、まず使うことはないでしょう。一時オブジェクトなどの rvalue は `const T&` または `T&&` で受けられるからです。込み入った用途で使うことがあるようですが、それは、どの種類の引数をどの種類の参照が受けられるか、オーバーロードでどのシグネチャが優先されるか、などを熟知した人がとても特殊な用途で使うものでしょうから、今我々が気にする必要はありません。

<a name="const"></a>
## const

### const を制するものは C++ を制す

[const や volatile ](https://en.cppreference.com/w/cpp/language/cv) キーワード は cv-qualifiers と呼ばれます。volatile はほぼ使わないので、ここでは気にしないことにして、const の有り難さについて説明していきます。const をうまく使うことで、コードの読み易さ、メンテナンスのしやすさは格段に上がると思ってください。const というのは我々がプログラム内の変数や関数に与える制約であり、const を使えばコンパイラがその制約を満たしているかどうかをチェックしてくれます。仮に const がなかったとしても C++ で作るプログラムに出来ることは変わりません。しかし、const を適切に使えば我々は const に大いに助けられていることを実感するでしょう。C 言語においても const は有り難いものでした。C++ にはメンバ関数によって振る舞いを自分で定義できるクラスがあり、これが const の仕組みを結びつくことでさらに強力に我々をサポートしてくれます。

### const の意味

const は constant の略で、不変の、という意味を持ちます。const を使うことで、変数やオブジェクトに「変えられないよ」という制約を与えることになります。別の言い方をすると、read-only という性質を持つわけです。人間というのは忘れっぽい生き物なので、昨日の時点で変えないと決めたものを、今日になると変えようとするコードを平気で書いてしまうものです。コンパイラが const の記述を見て、コラコラ、それは変えられないよ！と怒ってくれるので、我々は、ああ、そこには変えられないという制約を入れたんだった、と我に返ることができ、間違ったまま開発が進むことを避けられます。重要なことは、プログラムにおいて、データの変更よりも参照する(参照型変数と混同するのでややこしいですが、ここでは変更を伴わないアクセスのことです)ことの方が多いという事実です。const によりオブジェクトの変更が発生するコードを限定しておくことで、コードを読むときや変更するときに考えなければならないことがぐっと減ります。

### const 変数

変数の種類は 3 つあるのでした。値型変数、ポインタ、参照。これら全ての宣言に const をつけられます。ひとつづつ説明していきます。

値型変数を const として扱うときは、`const int i = 1;` のような宣言と初期化をします。こう書いたとき、変数 `i` は変更できません。変更できないとは、以下の意味を持ちます:

- non-const のものも含めてメンバ変数へのアクセスは全て const 扱いになり、変更できません。
- const メンバ関数は呼べますが、non-const メンバ関数は呼べません。
- 再代入はできません。そもそも宣言時の初期化以外の手段で値を設定できません。

クラス型 `A` の場合は、`const A a;` と宣言したとき、デフォルトコンストラクタが実行され、その後寿命が来るまで変更できません。通常は、コンストラクタに引数を渡して何らかの値を設定して使います。`const A a(arg1, arg2, ...);` のように。

ポインタの宣言では、const を付ける場所によって 2 通りの意味があります。`const A* const a;` と書いたとき、ひとつ目の const は、以下の意味を持ちます:

- (ポインタが指すオブジェクトの) メンバ変数へのアクセスは non-const のものも全部 const 扱いになり、変更できません。
- (ポインタが指すオブジェクトの) const メンバ関数は呼べますが、non-const メンバ関数は呼べません。

ふたつ目の const は、以下の意味を持ちます:

- 再代入できません。そもそも宣言時の初期化以外で値(アドレス)を設定できません。

二つ目の const を使うことはあまりありません。ポインタを使うときは、変数そのものが再代入可能かどうかよりも、それが指しているオブジェクトが変更できるかどうかに注目することが多いからです。

宣言した変数が const だった場合、周辺コードを修正しようとしたときに、我々はその変数は
「変更されない」ものとして扱って良いわけです。変更すべきでないと思って const で変数を宣言したけれど、後日、そのことを忘れて誤って変更しようとしたとき、コンパイラが怒ってくれますので間違いに気付きやすいのです。コードを読む人も、主にオブジェクトがどう変更されるかに注目して処理の流れを追うことが多いので、変数が const 宣言してあれば、初期化時以外は注意の対象から外して良いと分かるので、負担が減ります。

<a name="function-parameter-return-value-const"></a>
### 仮引数や返り値の const

関数の仮引数に `const int i` と書くのは好みの問題ですが、どうせ値渡しでコピーされているので、呼び出し元には影響がありませんし、関数シグネチャも値渡しの場合は const のありなしで区別されません。関数内ではもちろん const として扱われますが、インターフェースとしては違いがありませんので、私は値渡しの場合は const を付けないことにしています。もしどうしても const にしたかったら、`int i` と仮引数に書いておいて、関数の最初で `const int& j = i;` とでも宣言して `j` を使えばある程度目的は達成されるかも知れませんが、私から見てこれはやりすぎかなと感じます。

関数の返り値にも `const int` と書けますが、手元でコンパイラを動かしてみたら、warning が出ました。返り値の場合は挙動の違いが何もなく、`const int f()` と `int f()` のシグネチャの区別もされないからです。

関数の仮引数に `const int* p` と書いたとき、関数内では `p` が指すオブジェクトを変更できないことを意味します。呼び出し側は関数呼び出し後も `p` が指すオブジェクトが変更されていないことをほぼ確信できます。これがメンテナンス性にとても影響します。自分が読んでいる、または修正しているコードにおいて、関数呼び出しがあったとき、ポインタ渡しまたは参照渡しした変数の中身が関数呼び出しの前後で変わるかも知れないと分かれば、それがどう変わるのかを知る必要があります。実際は中身を変えていないとしても、引数に const がついていなければ、変えていないかどうかコードを読んで確認しないといけません。const がついていれば、その中身に立ち入ることなく安心して変えられていないことを信じられます。実は、無理矢理キャストすれば関数内でもオブジェクトを変更できますが、そんなことをするコードはお行儀が悪く、忌むべき存在です。const を適切に使った場合、`int* p` を引数として持っている関数は、 `p` が指すオブジェクトを変更することが想定され(条件分岐の結果変更しないケースはあるでしょうけれど)、`const int* p` を引数として持っている関数は、`p` の指すオブジェクトを変更しないことが分かります。ポインタ仮引数に関して、const の有無は異なるシグネチャとして区別されますので、`void f(const int* p)` 版と `void f(int* p)` 版は別の実体としてオーバーロード定義できます。

関数の返り値に `const T*` を返すとき(`T*` も同様ではありますが)、少なくとも関数内ローカル変数へのポインタではないことは確認しておいてください。寿命が尽きているオブジェクトを指しているポインタ/参照を dereference するのは明らかなバグですから。引数もしくはグローバル変数/メンバ変数に含まれるオブジェクト、それらが指しているヒープオブジェクトなどが指されているはずです。この const は、返った先でそれが指しているオブジェクトが変更されないことを約束します。`T*` を返してしまったらオブジェクトが変更されても文句はいえません。変更されたくない場合に const ポインタを返すことはよくあります。コードの影響範囲という意味において、`const T*` を返すか `T*` を返すかは明らかに後者の方が影響範囲は大きいと見るべきです。ただ、グローバル関数の返り値がポインタであるとき、const をつける意味は限られます。引数が const で変更する権限がないから、返り値にも const をつけているときくらいでしょうか。グローバル変数から辿れるオブジェクトを指している場合は、どうせ誰でも変更できますので、関数の返り値が const ポインタである意味があまりありません。その場合は関数側で const ポインタを返すのではなく、呼び出した側で返り値を受けとるのに const ポインタを使うのが良いかも知れません。そのコードでは変更しませんよ、という意思表示をすることの方が意味がありそうです。const ポインタを返す方法が多用されるのは、グローバル関数ではなくオブジェクトのメンバ関数で、メンバ変数へのポインタを返すときです。オブジェクト外の人に読まれるのは構わないけれど、変更されるのは拒否したいときに役に立ちます。

参照については、ポインタと同じなので、省略します。別途書いたように、`const T&` は多用しますが、`const T&&` はまず使われません。仮引数としての `const T&` は lvalue も rvalue も受けとれますから、通常困ることはありません。

### const メンバ変数

const メンバ変数とは、クラスのメンバ変数宣言において `const` を指定したものです。こうすると、コンストラクタの初期化子で初期化した後はオブジェクトの外はおろかメンバ関数内でも一切変更できなくなります。例えば、immutable objects (不変オブジェクト) を作る方法として、メンバ変数を全部 const にしてしまうという方法があります。こうすると、オブジェクト自身を const 変数として扱わなくてもメンバ変数が全て const なのだから一切変更できません。これはかなり極端な例だと思います。デフォルトコンストラクタを必ず使うことにして、後でメンバ変数を `init()` などのメンバ関数で設定しようと思っていたら、メンバ変数は const にできません。この 2 つの例は極端なものですが、現実のクラスの多くはその中間の手段を選択することになるのだと思います。

### const メンバ関数

const メンバ関数はとても重要です。オブジェクトが const であるとき、すなわち `const T` 型であるか、`const T&` または `const T*` で指されているとき、その変数は、const メンバ関数しか呼び出しできません。つまり、const オブジェクトの振る舞いを定義するために const メンバ関数と non-const メンバ関数を分けて定義します。const メンバ関数内では、non-const メンバ変数であっても const 扱いになり、変更できません。ですから、const メンバ関数はオブジェクトの状態を何も変更できないことになります。例外として、実際は変更されるんだけど、オブジェクトが変更されたと見做したくない場合、例えば mutex オブジェクトなどについては、`mutable` キーワードをつけてメンバ変数を宣言しておくことで、const メンバ関数の中で const 扱いになるのを回避できます。あくまで例外的な操作のためのものなので、多用は禁物です。

const メンバ関数は non-const メンバ関数とオーバーロードできますので、必要に応じて定義してください。以下のような例が挙げられます。
```c++
struct A
{
    std::string s;
    const char& get(size_t i) const { return s[i]; }
    char& get(size_t i) { return s[i]; }
};
```
const 版では const 参照を返すことによって、const オブジェクトとしての振る舞いを保つことができます。このようなオーバーロードは STL コンテナでよく使われています。

### const 教のお約束

C/C++  の const (もしくは他言語における同様の機能) を適切に使うことにより、コードの読み書きにおいて多大な恩恵を受けられると信じる宗教のことを const 教というらしいです。その教義は以下の 2 つだと思います:
1. const がついているのに、キャストなどを使って無理矢理中身を変更してしまってはいけない。
2. 実際は変更されないのに、const をつけずに放置してはいけない。

これらは const の恩恵を受けるための「お約束」なのに、それを破ってしまうと、const で信頼されている世界が崩壊していまい、メンテナンス性を著しく下げることになってしまいます。お約束が守られていないコードのやりとりをしてしまったら、人間関係もひょっとするとむちゃくちゃになってしまいます。それは冗談だとしても、あなたがお約束を破るコードを書いてしまい、const の恩恵を理解している人が読んだときは、ものすごくがっかりされるか、ものすごく怒られるか、もしくは両方でしょう。肝に命じてください。

とはいえ、例外はあります。実際にはオブジェクトの一部を変更するが、コードの意味としてオブジェクトが変更されたとはみなすべきではないとき、キャストや `mutable` を使って変更することは許容されるでしょう。ただし、何故そうするかをコメント等で書いておかないと誤解されることがあるかも知れません。キャストは使い方によってはとても危険な操作なので、コードを読む人も疑念を持って見るでしょうから。それから、スコープがとても小さい、高々数行の変数について、パっと見て実質的に const だということがすぐに分かるコードでも const を付けるべきかどうかという問いについて、私は別に見てすぐに分かるならそこまで気にする必要ないじゃないか、と思ったりはします。迷ったときは可読性やメンテナンス性という目的に合うかどうかを考えれば良いと思います。

const 教を無理に信じなくても、const が適切に使われるコードを読んだりメンテナンスする機会があれば、その有り難みを実感、納得でき、const をうまく使えるようになるでしょう。

## テンプレート

[C++ テンプレート](https://en.cppreference.com/w/cpp/language/templates)は、コードジェネレータであると同時にコンパイル時計算の手段でもあります。後者の役割は、テンプレートを使って実現するには不便すぎて一部の物好きのための機能としか思えませんでしたが、その役割は  `consexpr` が担いつつあるようなので、ここでは今後も典型的に使われるであろう前者の役割に注目します。

### 出来ること

テンプレートは、型を引数として受けとって、クラス(型)や関数をコンパイル時に生成するものです。型を具体的に示さずに、そのままクラスや関数のように記述することによってテンプレートを定義できます。もちろん、テンプレートに実際の型を渡して実体化するときに、その型が持っていない機能をテンプレートが使っていたら、コンパイルできずにエラーになります。

### 使い過ぎに注意

ベンチマークなどで設定パラメータを複数用意して実験することがあります。それぞれのパラメータ毎に `if` 文で動的に条件分岐するのは性能に影響が出そうだから嫌だな、と思ったことがあって、パラメータを最内ループで分岐させるのではなく、`main` 関数の最初で全部分岐させてしまい、それぞれのパラメータセットに特化したコードを実行するように、全部テンプレート引数として実装してみました。例えば以下のようなコードです:

```c++
tamlate <int A, int B, int C>
void disaptch3(const Option& opt)
{
    // A, B, C を条件として分岐する。
    // 条件分岐済みのコードが生成される。
}

template <int A, int B>
void dispatch2(const Option& opt)
{
    switch (opt.c) {
    case C1:
        dispatch3<A, B, C1>(opt); break;
    case C2:
        dispatch3<A, B, C2>(opt); break;
    // ...
    }
}

template <int A>
void dispatch1(const Option& opt)
{
    switch (opt.b) {
    case B1:
        dispatch2<A, B1>(opt); break;
    case B2:
        dispatch2<A, B2>(opt); break;
    // ...
    }
}

void dispatch0(const Option& opt)
{
    switch (opt.a) {
    case A1:
        dispatch1<A1>(opt); break;
    case A2:
        dispatch1<A2>(opt); break;
    // ...
    }
}
```

この例だとパラメータは 3 つですが、実際にはパラメータの数は 5 つくらいで、それぞれ 4 個くらいの値が存在していたでしょうか。・・・どうなったか皆さんもうお分かりですね？  4 の 5 乗個 = 1024 個程の似て異なるコードがテンプレートから生成され、本来なら数秒で済んでいたコンパイル時間が 10 分を越えたあげく、バイナリサイズが大きくなってしまいました。このように、組み合わせ爆発をするテンプレートを簡単に書いて実体化できますが、手に終えません。このような用途では、Just-in-time コンパイルの手段を模索するか、諦めて通常の `if` 文を使うしかないでしょう。

### パーフェクトフォワーディング

パーフェクトフォワーディング (日本語だと完全転送) は、lvalue reference で受ける実装と rvalue reference で受ける実装をオーバーロードしている関数があったとき、それをまとめてテンプレートで扱う仕組みです。ひとつなら 2 個テンプレート書けばいいじゃんと思いますが、呼び出しが n 段になると 2 の n 乗個定義しないといけなくなり、実質不可能なので、このような機能が欲しくなります。やり方は簡単:

1. 型引数にして (ここでは仮に `T` とします)、
2. 自らは `T&&` で受け (const とか付けたらダメです)、
3. `std::forward` で包んでオーバーロードしている関数に渡す

これだけです。何故このような動作になるかを知りたい人は、他の資料か C++ 仕様を参照ください。私は知識が足りなくてうまく説明できませんが、このような挙動を実現したい人達が、関数やテンプレートのシグネチャマッチングルールなどをうまく設定したのだと思います。

### テンプレートの限界

C++ のテンプレートをコンパイル時計算(メタプログラミング)のための言語と見做した場合、それは関数型プログラミング言語のような特徴を持っています。繰り返し処理は再帰を使わないと実現できないだとか、条件分岐もテンプレートの特殊化によるマッチングなどを利用して行われるとか。元々は、複数型に対して同じ処理をするコードをまとめて記述したい、という素朴な目的で作られたものが、結果として、ほぼチューリング完全の能力を、あくまで私の主観ですが、使いやすいとは言えない状態で獲得してしまったように思います。C++ のような手続型スタイルで、繰り返し処理や条件分岐をコンパイル時に実行し、コード生成する、という形のメタプログラミング言語だったら、もっと使い勝手の良いものだったんじゃないかと思います。同じことを思う人は C++ 標準策定に関わる人達にもいるようで、C++11 で登場した `constexpr` や C++17 で導入された `if constexpr` (これは完全な形でのコンパイル時条件分岐ではないのが悲しいところです。。) などが、より使いやすいメタプログラミング手段の萌芽に見え、ひそかに期待するところではあります。

### テンプレートを駆使する方へ

ここまで読んでも「俺/僕/私は C++テンプレートを極めるんだ！」という勇敢な方や「C++ テンプレート駆使しないとどうやらやりたいことが出来ないようだ。。。」という気の毒な方は頑張ってください。私はあまり詳しくないので良い情報を提供できませんが、いくつか日本語でも書籍は出ているようです。[boost template metaplogramming](https://www.boost.org/doc/libs/?view=category_metaprogramming) にもライブラリがあります。

## その他

ここでは、書いてみたものの分量が多くなかった雑多な話題について、まとめておきます。

### 入力のチェック

プログラム外部からの入力は、必ず動的に(実行時に)チェックしましょう。これがセキュリティのための大原則です。`assert` はデバッグやテスト用途で便利ですが、通常リリースビルドでは有効化されないものです。ただし、無闇に入力をチェックすると、チェックを無駄に複数回実施することになり、性能が低下してしまいますので、プログラムと外との境界についてはしっかりと意識してください。入力がそのまま実行される恐れがある場合は、文字列エスケープなどの処理で余計なことをされないようにする必要があります。また、入力データのサイズにも注意しましょう。必ず現実的な上限を設定しておき、それに従ってチェックすることが肝心です。なお、入力データをチェックなしに実行することは危険です。など無駄なことをやる羽目になり、逆に、外部ではないが、関数の引数をチェックする場合は、その目的に合わせて使い分けましょう。`check` と `assert` の使い分けは、



### コンパイラ特有の話

いくつかあるので列挙しながら説明します。

- GCC や Clang のコンパイラオプションには、 `-Wall -Wextra` を必ず付けて多くの warning を出してもらいましょう。そして、warning が出なくなるまでコードを修正しましょう。Warning が出るということはリスクのあるコードであることを意味しますし、たくさん warning が出る状態を放置すると、コード修正の難易度が上がりますから、やめましょう。
- `-pedantic` というオプションがあって、ISO C/C++ に準拠しない文法や記法は禁止するというコンパイラオプションです。場合によっては使いましょう。いわゆる GCC 拡張が使えなくなります。
- C++ 標準の話と、コンパイラが受けいれる記法や掃き出すコードの話と、CPU 内部でどう実行されるかの話は、繋がってはいますが厳密には違う世界の話なので、区別して考えましょう。例えば、メモリオーダーの話などがそれに当たります。
- Linux や Windows などの環境の違いによる long や unsigned long のサイズの違いには気をつけましょう。64bit Linux では、long は 64bit ですが、64bit Windows では 32bit です。64bit Windows の上で動く環境でも、64bit Cygwin では 64bit だったり、64bit MinGW では 32bit だったり、WSL ( (Windows Subsystem for Linux) ではやっぱり 64bit だったりします。これらの基本型のサイズのバリエーションについて、LLP64、LP64、ILP64 などと呼んで区別するようです。Windows や MinGW は LLP64、Linux、Cygwin, WSL は LP64 です。
- ヘッダファイルは同じ内容が複数回読まれないようにファイル先頭に `#ifndef HEADER_NAME` `#define HEADER_NAME`と ファイル末尾に`endif` を書くことで、一度しか読まれないことを保証する方法が昔は一般的でした。しかしこの方法は名前 (`HEADER_NAME`) の衝突や、`ifdef` と `endif` の対応がおかしくなるなどの面倒くささを抱えています。 昨今は、多くのコンパイラが `#pragma once` という記法をサポートしていて、ヘッダファイルの先頭にこれを 1 行書くだけで、一度しか読まれないことが保証されるようになりましたので、是非こちらを使ってください。
- マクロは、C 言語の時代から使えるものでしたが、プリプロセッサで処理され、ソースコード文法の解釈なしで文字列置換を基本とした処理がなされる仕組みなので、危険がいっぱいです。定数の定義にマクロを使う伝統もありましたが、C++ では適切な名前空間に const 変数を定義して使うようにしましょう。コードジェネレータとして使う場合は、テンプレートで代用できないかを検討しましょう。どうしても使わなければならない場面もあるとは思いますが、出来るだけ少なく留めるのが良いと思います。また、マクロはヘッダライブラリなども含めて名前空間がひとつしかないので、自分がマクロを定義するときは、多少長くなるのは仕方ないものとして、適切なプレフィックスやサフィックスを付けて名前が衝突しづらくなるようにしましょう。
- `inline` 指定では必ずしもインライン展開してくれるわけではないので、必ずインライン展開したい関数は、コンパイラに強制する必要があります。GCC や Clang だと `__attribute__((always_inline))` を使います。
- GCC や Clang でソースファイルをコンパイルするときに `-MMD` `-MP` の両方のオプションを指定しておくと、`make` コマンドが解釈できる依存関係ファイルを `.d` 拡張子のファイルとして出力してくれます。その一方で Makefile に以下のように書いておけばよろしく依存関係を解釈してくれます:
```makefile
  ALL_SRC=$(wildcard *.cpp)
  DEPEND_FILE=$(ALL_SRC:.cpp=.d)
  -include $(DEPEND_FILE)
```

### ヘッダとソース

ヘッダファイルは `.hpp` とか `.h` の拡張子を持ち、原則プロトタイプ宣言だけが書かれていて、ソースファイルは `.cpp` とか `.cc` の拡張子を持ち、関数やメンバ関数の実装が書いてあるものです。注意点として、テンプレートは、ファイルローカルでしか使われないものを除いてヘッダファイルに内容を記述しないといけません。また、インライン展開したい実装は、やはりファイルローカルでしか使われないものを除いてヘッダファイルに書く必要があります。ソースファイルに書いた実装は、LTO (Link-Time Optimization) の最適化を除いて、必ず通常の関数呼び出しとなります。`main()` 以外の実装をヘッダファイルに書くというスタイルもあり得ますが、複数の実行ファイルを生成する前提で、コード量が増えてくると、同じヘッダファイルに含まれる同じコードを複数回コンパイルすることになり、とにかくコンパイル時間が長くなってきてしまいます。インライン展開が必要なコードはプログラムの中でごくごく一部でしょうから、あとのコードは大人しくソースファイル内で実装して、リンクしましょう。

ヘッダファイルの仕組みは、歴史的経緯からこのような状況となっているもので、ヘッダの取り込み順序で挙動が変わってしまったり、複数回の取り込みによるコンパイル時間の増大などの問題があります。より現代的で便利なモジュールの仕組みを導入しようとする動きが C++ 標準の方であるようです。対象の公開範囲を調節するだとか、名前を適切に変えて取り込むだとかのメンテナンス性に直結する機能ですので、是非実現されて欲しいものですね。

### ラムダ式

C++11 で搭載されたラムダ式は、ちょっとした即席の関数オブジェクトを作って関数に渡したいときに便利だと思います。ただ、やはり使いすぎは禁物です。というのは、ラムダ式の参照キャプチャを使うと、実質的にラムダ式の外側のスコープにアクセスできるからです。

```c++
void func()
{
    int i = 0;
    // ...
    auto predicate = [&i]() {
        i = 1;
    };

    predicate();
    // i == 1
}
```

この例くらいならかわいいものですが、ラムダ式が巨大化して、参照する変数も増えると、コードの見通しはかなり悪くなってしまいます。そうなる前に、一部をきちんと名前のある通常の関数として切り出すなどのリファクタリングを行うことをオススメします。

C++14 で追加されたジェネリックラムダ、C++17 で追加された `constexpr` ラムダなど、ラムダ式も機能が増えていますが、やはり実際にどんな挙動をするかを分かった上で、可読性についても十分考慮して使ってください。曖昧な理解のままで使うくらいなら使わない方がずっとマシです。

### auto や decltype

C++11 で使えるようになって、その後 C++14 や C++17 で改善され続けている [auto](https://en.cppreference.com/w/cpp/language/auto)や [decltype](https://en.cppreference.com/w/cpp/language/decltype) は、利用範囲が増えてきました。テンプレートを定義する場合は、これらを使わないと実装が難しいものもあるようですが、通常の関数内で、気軽に使うのはよく考えてからにしましょう。コードの可読性という視点では、明らかに分かるもの以外で `auto` や `decltype` を使うのはオススメできません。例えば、[range-based for loop](https://en.cppreference.com/w/cpp/language/range-for)  の要素を受ける変数宣言や、イテレータを返す関数を受ける変数宣言などは、人間が見ても型が推論しやすいでしょうから、`auto` などを使っても読み易さが落ちにくく、かつ長ったるい型名の記述が減って書く側も読む側もうれしいことでしょう。それからラムダ式に名前を付けるときは `auto` を使うのが典型的な使い方です。私はこの 3 つのケースについてはあまり気にせずに `auto` を使っています。繰り返しになりますが、型推論してくれるからといって安易に `auto` や `decltype` を使うのはやめましょう。

### コンテナとイテレータ

どのコンテナをどのように使うべきかについては、多くの資料がありますから参考にしてください。ある型のオブジェクトからなる集合を管理するコンテナとして `std::vector`、 `std::list`、 `std::deque` などがありますが、性能特性が違うので、アクセスの方法によって使いわけられるべきもの達です。また、`std::map` と `std::unordered_map` は key-value 型のデータを格納するためのものです。木構造か、ハッシュテーブルかで実装が分かれ、性能特性や能力も違います。コンテナのメンバ関数は、C++ 標準で計算量などの制約が付けられていたりします。例えば、`size()` メンバは必ず計算量 `O(1)` で実行できることなどです。

イテレータについて重要なこととして、 `begin()` は閉区間 `end()` は開区間であることを覚えておいてください。範囲というものは、閉区間で始まり、開区間で終わるという扱いにするのが汎用的に便利かと思います。その理由は、範囲の分割や隣合う範囲の集約操作が簡単だからとか、`0` 始まりの for 文において終点と実行回数が一致するという分かりやすさもあるかと思います。一番基本的な `for` 文は、以下のように書くことが多いと思います:

​```c++
std::vector<int> v(n);
for (size_t i = 0; i < n; i++) {
    // using v[i]
}
```

閉区間で始まり、開区間で終わりますね。これは、`0`, `1`, ..., `n-1` までの `n` 回実行される for loop です。逆順のアクセスは、

​```c++
std::vector<int> v(n);
for (size_t i = n; i > 0; i--) {
    // using v[i - 1]
}
```

このように記述できます。これに慣れれば、始点と終点の扱いを気にする頻度が減り、バグが入りにくくなる気がしますので、慣れてない人は begin は閉区間、end は開区間のパターンを使うように心掛けてみましょう。

### テスト

様々なテストフレームワークがありますが、何を使うとしても CI でリグレッションテストを実行することを意識しておけば良いと思います。ごくごく単純なユニットテスト用途で十分なものとして、[cybozulib](https://github.com/herumi/cybozulib) の `test.hpp` をオススメしておきます。

```c++
#include "cybozu/test.hpp"

CYBOZU_TEST_AUTO(test_a)
{
    int i = 0; j = 0;
    CYBOZU_TEST_EQUAL(i, j);
    CYBOZU_TEST_ASSERT(i != 0);
}
```
このように書いてコンパイルすると、テスト成功時は 0 、失敗時はそれ以外が返る実行ファイルが出来ます。

環境の整備や初期化などが必要なテストは、もっと複雑な機構が欲しくなるかも知れませんが、必要に応じてスクリプトを作ったりして対応すれば良いと思います。実行したらテスト成功か失敗かが判別できる出力をし、自動化しやすい形でプログラムとして作っておくのが重要です。

### boost ライブラリ

[boost ライブラリ](https://www.boost.org/)は C++ の標準ライブラリではありませんが、一部の機能が C++ 標準に取り込まれた実績が多くあるライブラリです。つまり、boost に入っている機能は次世代の C++ 標準に取り込まれる可能性があります。

自分の使いたい道具が C++ 標準になくて、boost にあったなら、使いたくなるのは当たり前です。しかし、ちょっと待ってください。あなたの書こうとしているプログラムは何年使われるものですか？何年メンテナンスする必要のあるものですか？boost は先進的なライブラリなので、古いバージョンは新しいコンパイラでビルドできなくなるかも知れませんし、新しいバージョンの boost ライブラリは API が変わっているかも知れません。OS のパッケージシステムなどで提供される boost はバージョンがひとつしか選べないか、選べても少ないでしょうし、新しいバージョンの OS には新しい boost が入っています。あなたのプログラムのメンテナンスのことを考えて、boost を使うかどうかを決めると良いでしょう。boost のヘッダライブラリだけを使う分には、相対的には互換性問題が発生するリスクが少ないと思います。


## おわりに

⾊々と書きましたが、本当に C++ 初⼼者がこれを読んで初⼼者脱出できるのか。。。という不安もあります。多くの⼈のフィードバックを経て、叩かれ磨かれていくべきと思いますので、是⾮フィードバックを著者までお願いします。郷に⼊っては郷に従えの部分もあるでしょうけれど、どのような⾔語を使う場合でも、プログラムの設計における⼤事なことはあまり変わらないと思いますし、それを C++ においてはどのように実現するか、ということを重視して書いてきたつもりです。本ドキュメントによって、C++ でメンテナンスしやすく、安全で、速いコードを書く⼈が増え、C++ ⼈⼝が増え、C++ が栄えて私が C++ を便利に使える時代が続いてくれたらうれしいな、と思います。Rust や Go に浮気するかも知れませんがね ;)


## 更新履歴

- 2018-08-10 v0.3  継承回り修正、追記
- 2018-08-07 v0.2  色々と追加、改善
- 2018-07-30 v0.1 最初のバージョン
